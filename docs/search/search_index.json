{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Pegasus is an experimental emulator frontend, focusing on customizability, cross platform support (including embedded) and high performance. Here you can find the related documentation, development notes and guides. Back to pegasus-frontend.org User guide Getting started! Default controls Plaform notes Android Linux RetroPie Adding games Metadata files Asset files Real world examples Other sources (Steam, GOG, etc.) Scripting Installing themes Config directories Breaking changes Theme development Overview QML tutorials Available QML modules Step-by-step: Simple theme Step-by-step: Flixnet theme API reference Core development Installing Qt on desktop Cross compiling Qt for embedded Building Pegasus Deployment Translations","title":"Home"},{"location":"#home","text":"Pegasus is an experimental emulator frontend, focusing on customizability, cross platform support (including embedded) and high performance. Here you can find the related documentation, development notes and guides. Back to pegasus-frontend.org","title":"Home"},{"location":"#user-guide","text":"Getting started! Default controls Plaform notes Android Linux RetroPie Adding games Metadata files Asset files Real world examples Other sources (Steam, GOG, etc.) Scripting Installing themes Config directories Breaking changes","title":"User guide"},{"location":"#theme-development","text":"Overview QML tutorials Available QML modules Step-by-step: Simple theme Step-by-step: Flixnet theme API reference","title":"Theme development"},{"location":"#core-development","text":"Installing Qt on desktop Cross compiling Qt for embedded Building Pegasus Deployment Translations","title":"Core development"},{"location":"dev/build/","text":"Building Pegasus Pegasus is a C++ program that uses the Qt framework. To build it for on your OS or device, you'll need a C++11 supporting compiler (eg. G++ 4.9, Visual Studio 2017), Qt 5.8 or later (version is important!) for your platform, and at least the following additional Qt components: QML module Qt Quick 2 module Multimedia module (might be called as MultimediaQuick) Svg module Gamepad module Qt also provides a graphical IDE called Qt Creator, which you can use if you wish, but it's not a requirement. For installing Qt, see this page . Using Qt Creator Open Qt Creator and open the project file ( pegasus.pro ) Qt Creator will ask you which Qt setup (\"kit\") you want to use (in case you've installed multiple versions), and where you want to place the generated files (see Details). If everything's OK, click Configure Project. (optional) Change the configuration (see here ) In the bottom left corner, on the sidebar of Qt Creator, you can find 4 buttons: with the button that looks like a desktop monitor, you can change the build type (optimized Release build or development-friendly but slower Debug build) the green arrow will build and run the program the green arrow with a bug will also open several debug toolbars the hammer will build the project but won't start the application Change the build type to Release, and press the green arrow to build and run the project. Using the command line Create a build directory somewhere, and cd into it Call qmake , the configuration tool of Qt: /path/to/qmake path/to/project [options] . If you have multiple Qt versions installed, make sure you call the right qmake . If you've installed using the official release from the Qt site, you can find it in [qt-installdir]/Qt5/[version]/gcc_64/bin (you can add it to your $PATH if you want, but it's not necessary). You can also change some configuration options, which you can find here . Call make (optional) Call make install Configuration options You can change build parameters to qmake (the Qt configuration tool) by appending KEY=VALUE pairs to its command line call. If you're using Qt Creator, you can find these settings on the Projects - Build settings tab, where you can modify the Additional arguments option (see here ). The following additional parameters are available for QMake. Usually they don't need to be touched unless you wish to set up a certain installation structure (eg. on Linux). Option Description INSTALLDIR The general installation directory used by make install . Defaults to /opt/pegasus-frontend on Linux and C:\\pegasus-frontend on Windows. INSTALL_BINDIR The installation directory of the executable. You can use this to place the binary under /usr/bin/ , for example. Defaults to INSTALLDIR . INSTALL_DATADIR The installation directory of the data files (if there's any), and where to look for them. You can use this to add another directory where Pegasus looks for themes, for example. Defaults to INSTALLDIR . INSTALL_DESKTOPDIR Linux only, if set, make install will create an XDG desktop file there (making Pegasus appear in the main menu). Unset by default, on most distros /usr/share/applications is a good value. INSTALL_ICONDIR Linux only, if set, make install will create an XDG icon file there (making Pegasus have an icon on the tray and the menu). Unset by default, on most distros /usr/share/pixmaps or /usr/share/icons/hicolor/128x128/apps is a good value.","title":"Building"},{"location":"dev/build/#building-pegasus","text":"Pegasus is a C++ program that uses the Qt framework. To build it for on your OS or device, you'll need a C++11 supporting compiler (eg. G++ 4.9, Visual Studio 2017), Qt 5.8 or later (version is important!) for your platform, and at least the following additional Qt components: QML module Qt Quick 2 module Multimedia module (might be called as MultimediaQuick) Svg module Gamepad module Qt also provides a graphical IDE called Qt Creator, which you can use if you wish, but it's not a requirement. For installing Qt, see this page .","title":"Building Pegasus"},{"location":"dev/build/#using-qt-creator","text":"Open Qt Creator and open the project file ( pegasus.pro ) Qt Creator will ask you which Qt setup (\"kit\") you want to use (in case you've installed multiple versions), and where you want to place the generated files (see Details). If everything's OK, click Configure Project. (optional) Change the configuration (see here ) In the bottom left corner, on the sidebar of Qt Creator, you can find 4 buttons: with the button that looks like a desktop monitor, you can change the build type (optimized Release build or development-friendly but slower Debug build) the green arrow will build and run the program the green arrow with a bug will also open several debug toolbars the hammer will build the project but won't start the application Change the build type to Release, and press the green arrow to build and run the project.","title":"Using Qt Creator"},{"location":"dev/build/#using-the-command-line","text":"Create a build directory somewhere, and cd into it Call qmake , the configuration tool of Qt: /path/to/qmake path/to/project [options] . If you have multiple Qt versions installed, make sure you call the right qmake . If you've installed using the official release from the Qt site, you can find it in [qt-installdir]/Qt5/[version]/gcc_64/bin (you can add it to your $PATH if you want, but it's not necessary). You can also change some configuration options, which you can find here . Call make (optional) Call make install","title":"Using the command line"},{"location":"dev/build/#configuration-options","text":"You can change build parameters to qmake (the Qt configuration tool) by appending KEY=VALUE pairs to its command line call. If you're using Qt Creator, you can find these settings on the Projects - Build settings tab, where you can modify the Additional arguments option (see here ). The following additional parameters are available for QMake. Usually they don't need to be touched unless you wish to set up a certain installation structure (eg. on Linux). Option Description INSTALLDIR The general installation directory used by make install . Defaults to /opt/pegasus-frontend on Linux and C:\\pegasus-frontend on Windows. INSTALL_BINDIR The installation directory of the executable. You can use this to place the binary under /usr/bin/ , for example. Defaults to INSTALLDIR . INSTALL_DATADIR The installation directory of the data files (if there's any), and where to look for them. You can use this to add another directory where Pegasus looks for themes, for example. Defaults to INSTALLDIR . INSTALL_DESKTOPDIR Linux only, if set, make install will create an XDG desktop file there (making Pegasus appear in the main menu). Unset by default, on most distros /usr/share/applications is a good value. INSTALL_ICONDIR Linux only, if set, make install will create an XDG icon file there (making Pegasus have an icon on the tray and the menu). Unset by default, on most distros /usr/share/pixmaps or /usr/share/icons/hicolor/128x128/apps is a good value.","title":"Configuration options"},{"location":"dev/cross-compile-qt/","text":"Cross compiling Qt for embedded platforms Danger Cross compiling Qt is not trivial, you'll need some experience setting it all up. If you'd just like to make Pegasus run on a new device, consider opening a new issue ! This documentation lists the configurations I personally use when building Qt. If the latest Qt is not available for your platform, or you're not pleased with it (eg. hardware acceleration is disabled), you'll need to build it manually. You can get the latest officially released source code from the Qt website, from here (select open source, click 'All downloads' on the bottom, then search for 'Source packages'). The general steps and requirements are described in the Qt documentation . Building Qt takes significant time, about 30-60 minutes on a good desktop PC, depending on the selected components. It requires at least 2 GB of RAM and 6.5 GB free space. Do not try to build it on your $5 board computer. Instead, you can cross compile Qt. Cross compilation means the program or library you build will run on a different architecture or platform than your own PC. For example, if you're on Linux, you can build programs that will run on Windows, or on a phone or embedded device. For this, you'll need a toolchain , a compiler that generates code for a certain platform, and a sysroot , a collection of libraries from the target device. Getting a toolchain and sysroot is different for every platform; you can find cross compilers for the popular targets, eg. ARMv7-Linux, while for others you might need to build a whole custom GCC. You'll have look around for them for your platform. For the Raspberry Pi cross compilation, this guide was very helpful: https://wiki.qt.io/RaspberryPi2EGLFS . This also shows how you can set up Qt Creator for testing and such. The configurations below are mainly based on the Debian automatic builds, and the guide mentioned above. If you haven't read the official Qt docs yet, do it now. The configure step produces a detailed status report; make sure everything looks correct. You'll need everything under QML and Qt Quick (except maybe DirectX 12), and depending on your platform, 'EGLFS' under 'QPA backends' and at least one of the 'EGLFS details', that matches your device (eg. EGLFS Rasberry Pi). You might also want the X11 options off, if you won't use it. See configure --help or the documentation for the available options. Raspbian sysroot The sysroot used for compilation is based on Raspbian, with the following additional packages installed: apt-get build-dep -y qt4-x11 libqt5gui5 apt-get install -y libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 apt-get install -y libopenal-dev libsqlite3-dev libfontconfig-dev apt-get install -y libglib2.0-dev gstreamer1.0-omx libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev apt-get install -y libsmbclient-dev libssh-dev libsdl2-dev Raspberry Pi 1 / Zero (ARMv6) toolchain: https://github.com/raspberrypi/tools , cloned to /opt/raspberrypi-tools sysroot: see Raspbian sysroot ../configure \\ -opensource \\ -confirm-license \\ -release \\ -strip \\ -no-rpath \\ -make libs \\ -skip qtwebengine \\ -skip wayland \\ -device linux-rasp-pi-g++ \\ -opengl es2 \\ -device-option CROSS_COMPILE=/opt/raspberrypi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf- \\ -sysroot /opt/rpi-sysroot \\ -prefix /opt/qt58-rpi1 \\ -extprefix /opt/qt58-rpi1 \\ -hostprefix /opt/qt58-rpi1_hosttools \\ -no-use-gold-linker \\ -openssl \\ -fontconfig \\ -gstreamer 1.0 \\ -no-xcb \\ -no-dbus \\ -no-glib \\ -no-icu \\ -system-zlib \\ -system-libpng \\ -system-libjpeg \\ -system-sqlite \\ -verbose Raspberry Pi 2 (ARMv7) / 3 (ARMv8, but v7 compatible) NOTE: The difference is the -device parameter and the output paths. toolchain: https://github.com/raspberrypi/tools , cloned to /opt/raspberrypi-tools sysroot: see Raspbian sysroot ../configure \\ -opensource \\ -confirm-license \\ -release \\ -strip \\ -no-rpath \\ -make libs \\ -skip qtwebengine \\ -skip wayland \\ -device linux-rasp-pi2-g++ \\ -opengl es2 \\ -device-option CROSS_COMPILE = /opt/raspberrypi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf- \\ -sysroot /opt/rpi-sysroot \\ -prefix /opt/qt58-rpi2 \\ -extprefix /opt/qt58-rpi2 \\ -hostprefix /opt/qt58-rpi2_hosttools \\ -no-use-gold-linker \\ -openssl \\ -fontconfig \\ -gstreamer 1 .0 \\ -no-xcb \\ -no-dbus \\ -no-glib \\ -no-icu \\ -system-zlib \\ -system-libpng \\ -system-libjpeg \\ -system-sqlite \\ -verbose X11 static build This was actually a native build, so the cross compilation options aren't needed. ../configure -opensource -confirm-license -release -strip -no-rpath -static -c++std c++11 -make libs -skip qtwebengine -skip wayland -prefix /opt/qt58-x11-static -openssl -gstreamer 1.0 -fontconfig -no-dbus -verbose -no-glib -qt-zlib -platform linux-g++ -no-icu -qpa xcb -xcb","title":"Cross compile Qt"},{"location":"dev/cross-compile-qt/#cross-compiling-qt-for-embedded-platforms","text":"Danger Cross compiling Qt is not trivial, you'll need some experience setting it all up. If you'd just like to make Pegasus run on a new device, consider opening a new issue ! This documentation lists the configurations I personally use when building Qt. If the latest Qt is not available for your platform, or you're not pleased with it (eg. hardware acceleration is disabled), you'll need to build it manually. You can get the latest officially released source code from the Qt website, from here (select open source, click 'All downloads' on the bottom, then search for 'Source packages'). The general steps and requirements are described in the Qt documentation . Building Qt takes significant time, about 30-60 minutes on a good desktop PC, depending on the selected components. It requires at least 2 GB of RAM and 6.5 GB free space. Do not try to build it on your $5 board computer. Instead, you can cross compile Qt. Cross compilation means the program or library you build will run on a different architecture or platform than your own PC. For example, if you're on Linux, you can build programs that will run on Windows, or on a phone or embedded device. For this, you'll need a toolchain , a compiler that generates code for a certain platform, and a sysroot , a collection of libraries from the target device. Getting a toolchain and sysroot is different for every platform; you can find cross compilers for the popular targets, eg. ARMv7-Linux, while for others you might need to build a whole custom GCC. You'll have look around for them for your platform. For the Raspberry Pi cross compilation, this guide was very helpful: https://wiki.qt.io/RaspberryPi2EGLFS . This also shows how you can set up Qt Creator for testing and such. The configurations below are mainly based on the Debian automatic builds, and the guide mentioned above. If you haven't read the official Qt docs yet, do it now. The configure step produces a detailed status report; make sure everything looks correct. You'll need everything under QML and Qt Quick (except maybe DirectX 12), and depending on your platform, 'EGLFS' under 'QPA backends' and at least one of the 'EGLFS details', that matches your device (eg. EGLFS Rasberry Pi). You might also want the X11 options off, if you won't use it. See configure --help or the documentation for the available options.","title":"Cross compiling Qt for embedded platforms"},{"location":"dev/cross-compile-qt/#raspbian-sysroot","text":"The sysroot used for compilation is based on Raspbian, with the following additional packages installed: apt-get build-dep -y qt4-x11 libqt5gui5 apt-get install -y libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 apt-get install -y libopenal-dev libsqlite3-dev libfontconfig-dev apt-get install -y libglib2.0-dev gstreamer1.0-omx libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev apt-get install -y libsmbclient-dev libssh-dev libsdl2-dev","title":"Raspbian sysroot"},{"location":"dev/cross-compile-qt/#raspberry-pi-1-zero-armv6","text":"toolchain: https://github.com/raspberrypi/tools , cloned to /opt/raspberrypi-tools sysroot: see Raspbian sysroot ../configure \\ -opensource \\ -confirm-license \\ -release \\ -strip \\ -no-rpath \\ -make libs \\ -skip qtwebengine \\ -skip wayland \\ -device linux-rasp-pi-g++ \\ -opengl es2 \\ -device-option CROSS_COMPILE=/opt/raspberrypi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf- \\ -sysroot /opt/rpi-sysroot \\ -prefix /opt/qt58-rpi1 \\ -extprefix /opt/qt58-rpi1 \\ -hostprefix /opt/qt58-rpi1_hosttools \\ -no-use-gold-linker \\ -openssl \\ -fontconfig \\ -gstreamer 1.0 \\ -no-xcb \\ -no-dbus \\ -no-glib \\ -no-icu \\ -system-zlib \\ -system-libpng \\ -system-libjpeg \\ -system-sqlite \\ -verbose","title":"Raspberry Pi 1 / Zero (ARMv6)"},{"location":"dev/cross-compile-qt/#raspberry-pi-2-armv7-3-armv8-but-v7-compatible","text":"NOTE: The difference is the -device parameter and the output paths. toolchain: https://github.com/raspberrypi/tools , cloned to /opt/raspberrypi-tools sysroot: see Raspbian sysroot ../configure \\ -opensource \\ -confirm-license \\ -release \\ -strip \\ -no-rpath \\ -make libs \\ -skip qtwebengine \\ -skip wayland \\ -device linux-rasp-pi2-g++ \\ -opengl es2 \\ -device-option CROSS_COMPILE = /opt/raspberrypi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf- \\ -sysroot /opt/rpi-sysroot \\ -prefix /opt/qt58-rpi2 \\ -extprefix /opt/qt58-rpi2 \\ -hostprefix /opt/qt58-rpi2_hosttools \\ -no-use-gold-linker \\ -openssl \\ -fontconfig \\ -gstreamer 1 .0 \\ -no-xcb \\ -no-dbus \\ -no-glib \\ -no-icu \\ -system-zlib \\ -system-libpng \\ -system-libjpeg \\ -system-sqlite \\ -verbose","title":"Raspberry Pi 2 (ARMv7) / 3 (ARMv8, but v7 compatible)"},{"location":"dev/cross-compile-qt/#x11-static-build","text":"This was actually a native build, so the cross compilation options aren't needed. ../configure -opensource -confirm-license -release -strip -no-rpath -static -c++std c++11 -make libs -skip qtwebengine -skip wayland -prefix /opt/qt58-x11-static -openssl -gstreamer 1.0 -fontconfig -no-dbus -verbose -no-glib -qt-zlib -platform linux-g++ -no-icu -qpa xcb -xcb","title":"X11 static build"},{"location":"dev/deploy/","text":"Deployment Qt uses lots of modules, plugins and QML files, which makes it somewhat hard to create deployable packages manually. Fortunately, there are tools that can collect the necessary files for you. See the general Qt documentation here , especially the platform-specific notes. Since most of the details are described there, I'll just list the commands I usually use. Linux Static builds If you've manually built Qt as a static library, a simple make install will likely be enough. You can use linuxdeployqt to create AppImages: ./linuxdeployqt-continuous-x86_64.AppImage \\ -qmldir build dir \\ -bundle-non-qt-libs \\ install dir cp /path/to/libQt5Svg.so.5 ./lib/ ./linuxdeployqt-continuous-x86_64.AppImage \\ -appimage \\ install dir Windows windeployqt --release --qmldir build dir --no-translations --no-opengl-sw installation dir macOS make creates a regular .app release. Similarly to Linux, you can use it as-is for static builds, or use macdeployqt to collect the liraries and optionally generate a DMG file.","title":"Deployment"},{"location":"dev/deploy/#deployment","text":"Qt uses lots of modules, plugins and QML files, which makes it somewhat hard to create deployable packages manually. Fortunately, there are tools that can collect the necessary files for you. See the general Qt documentation here , especially the platform-specific notes. Since most of the details are described there, I'll just list the commands I usually use.","title":"Deployment"},{"location":"dev/deploy/#linux","text":"Static builds If you've manually built Qt as a static library, a simple make install will likely be enough. You can use linuxdeployqt to create AppImages: ./linuxdeployqt-continuous-x86_64.AppImage \\ -qmldir build dir \\ -bundle-non-qt-libs \\ install dir cp /path/to/libQt5Svg.so.5 ./lib/ ./linuxdeployqt-continuous-x86_64.AppImage \\ -appimage \\ install dir","title":"Linux"},{"location":"dev/deploy/#windows","text":"windeployqt --release --qmldir build dir --no-translations --no-opengl-sw installation dir","title":"Windows"},{"location":"dev/deploy/#macos","text":"make creates a regular .app release. Similarly to Linux, you can use it as-is for static builds, or use macdeployqt to collect the liraries and optionally generate a DMG file.","title":"macOS"},{"location":"dev/install-qt/","text":"Installing Qt for desktop Qt is a cross-platform application framework used by Pegasus. At least Qt 5.8 is requred, with 5.9 or later recommended for better performance on embedded platforms. For desktop platforms you can get the Qt tools using their installer: Download the Qt installer Then walk through the installation, and select the component \"Desktop gcc\" (Linux), \"MinGW\" (Windows) or \"macOS\" for macOS: Now you have the Qt libraries and the Qt Creator IDE installed. Components on Windows On Windows you can choose between MinGW and MSVC compiler packages. If you're planning to edit the source code and you want to use Visual Studio, you can select the matching MSVC component instead of MinGW. Embedded These instructions are for desktop platforms. For embedded devices, you have to compile Qt manually, or use the prebuilt libraries available on Pegasus' GitHub page. See Cross compile Qt . Alternative installations Linux On many Linux distros, the Qt libraries in the official repositories are often several years old (as a trade-off between stability and access to the latest software), or miss some components. Ubuntu, Debian Debian 10 (buster/testing) contains an up-to-date Qt release and building Pegasus should be possible. Ubuntu 18.04 contains an up-to-date Qt release, but misses a few necessary packages. You can either use the Qt installer (see above), or the followin PPAs: On Ubuntu , you can use the following PPAs to get the latest Qt releases: sudo add-apt-repository ppa:beineri/opt-qt-5.11.1-bionic sudo apt-get update sudo apt-get install \\ qt59declarative \\ qt59graphicaleffects \\ qt59gamepad \\ qt59imageformats \\ qt59multimedia \\ qt59svg \\ qt59tools source /opt/qt511/bin/qt511-env.sh To use this installation, you will need to call /opt/qt511/bin/qt511-env.sh (or /opt/qt59/bin/qt59-env.sh on 14.x/16.x) every time you open a new terminal. You can do this by adding the source ... line above to your ~/.bashrc file (or whatever shell you use). 16.04 and 14.04 On older Ubuntu releases, you can use ppa:beineri/opt-qt596-xenial and ppa:beineri/opt-qt596-trusty . Arch If you're using Arch , you can get Qt from AUR; here's the relevant wiki page . Windows MSYS2 Qt is available in the MSYS2 repos. See https://wiki.qt.io/MSYS2 . vcpkg At the time of writing, Qt 5.9 is available in vcpkg as a port. macOS Homebrew Qt is available in the Homebrew repos, but may not be up to date. See http://brewformulas.org/qt5 .","title":"Installing Qt"},{"location":"dev/install-qt/#installing-qt-for-desktop","text":"Qt is a cross-platform application framework used by Pegasus. At least Qt 5.8 is requred, with 5.9 or later recommended for better performance on embedded platforms. For desktop platforms you can get the Qt tools using their installer: Download the Qt installer Then walk through the installation, and select the component \"Desktop gcc\" (Linux), \"MinGW\" (Windows) or \"macOS\" for macOS: Now you have the Qt libraries and the Qt Creator IDE installed. Components on Windows On Windows you can choose between MinGW and MSVC compiler packages. If you're planning to edit the source code and you want to use Visual Studio, you can select the matching MSVC component instead of MinGW. Embedded These instructions are for desktop platforms. For embedded devices, you have to compile Qt manually, or use the prebuilt libraries available on Pegasus' GitHub page. See Cross compile Qt .","title":"Installing Qt for desktop"},{"location":"dev/install-qt/#alternative-installations","text":"","title":"Alternative installations"},{"location":"dev/install-qt/#linux","text":"On many Linux distros, the Qt libraries in the official repositories are often several years old (as a trade-off between stability and access to the latest software), or miss some components.","title":"Linux"},{"location":"dev/install-qt/#ubuntu-debian","text":"Debian 10 (buster/testing) contains an up-to-date Qt release and building Pegasus should be possible. Ubuntu 18.04 contains an up-to-date Qt release, but misses a few necessary packages. You can either use the Qt installer (see above), or the followin PPAs: On Ubuntu , you can use the following PPAs to get the latest Qt releases: sudo add-apt-repository ppa:beineri/opt-qt-5.11.1-bionic sudo apt-get update sudo apt-get install \\ qt59declarative \\ qt59graphicaleffects \\ qt59gamepad \\ qt59imageformats \\ qt59multimedia \\ qt59svg \\ qt59tools source /opt/qt511/bin/qt511-env.sh To use this installation, you will need to call /opt/qt511/bin/qt511-env.sh (or /opt/qt59/bin/qt59-env.sh on 14.x/16.x) every time you open a new terminal. You can do this by adding the source ... line above to your ~/.bashrc file (or whatever shell you use). 16.04 and 14.04 On older Ubuntu releases, you can use ppa:beineri/opt-qt596-xenial and ppa:beineri/opt-qt596-trusty .","title":"Ubuntu, Debian"},{"location":"dev/install-qt/#arch","text":"If you're using Arch , you can get Qt from AUR; here's the relevant wiki page .","title":"Arch"},{"location":"dev/install-qt/#windows","text":"","title":"Windows"},{"location":"dev/install-qt/#msys2","text":"Qt is available in the MSYS2 repos. See https://wiki.qt.io/MSYS2 .","title":"MSYS2"},{"location":"dev/install-qt/#vcpkg","text":"At the time of writing, Qt 5.9 is available in vcpkg as a port.","title":"vcpkg"},{"location":"dev/install-qt/#macos","text":"","title":"macOS"},{"location":"dev/install-qt/#homebrew","text":"Qt is available in the Homebrew repos, but may not be up to date. See http://brewformulas.org/qt5 .","title":"Homebrew"},{"location":"dev/translate/","text":"Translations Pegasus supports most languages in use today, and you can easily add new translations for any locale. The translations are stored in simple text files in XML format, so the only thing you need is a text editor. There's also a graphical tool to make things easier (see below). The translations themselves are collected in a separate repository here , which is also included as a Git submodule in the main Pegasus repo. In short (optional) download the Qt tools download the translation repo create a copy of pegasus_en.ts for your language open the new file in Qt Linguist or your editor of choice, and translate the strings open a new issue in the translation repo and attach your TS file Todo In the future, there'll be likely some kind of online site for managing translations. File format and name The translation files are text files in XML format, encoded in UTF-8. Their file name includes the BCP47 language tag of the locale the they're made for. Usually this means the following structure: pegasus_[language][-script][-country].ts where language is the language code, mentioned above. Two- or rarely three letters, lowercase. optionally, script defines the writing system, like simplified/traditional chinese or Old German Runes. Four letters, title case. optionally, country defines regional settings, which affects things like date format, usually. Two letters, uppercase. for example, hi-Deva-IN means Hindi language, Devanagari script, and the regional settings of India. Usually though the two letter language code is enough for most locales. Two letter language codes can be found here , and four letter script codes here . 1. Preparing the tools You can use any decent text editor to edit the files. There's also a graphical translation tool called Qt Linguist : Qt Linguist is included with Qt, see here . After installation, search for linguist in the installation directory of Qt (Linux) or the Start menu (Windows). 2. Prepare the translation files You can find the translation files in this repository . If you have no experience with Git, just click on the green Clone or download button, then Download ZIP . Then, create a copy of pegasus_en.ts , and change en to your locale's code (see above). Developer note You can create this file with lupdate ../src -ts pegasus_en.ts -no-obsolete . 3. Translate the file Open your new file in a text editor or in Qt Linguist. If you're using a text editor , the translateable strings are inside message tags: you can see the original text in the source tag, and you can provide your translation in translation . Also change the language tag on the top of the file ( TS ... ). If you're using Qt Linguist , first set your language in Edit - Translation file settings - Target language . After that, you can select a \"module\" (group of texts) on the left, then see the relevant strings in the upper-middle panel. You can add the translation in the center panel (marked with \"1\" on the picture above). Then press the green checkmark on the top toolbar (or press Ctrl+Enter) to jump to the next untranslated line. A detailed guide for Qt Linguist can be found here . Help %1 , %2 , ... in the text is a placeholder for additional values, such as numbers, file names, etc. screenshots for most of the translateable text can be found here 4. (optional) Rebuild Pegasus and test the translation At the moment, all translation files must be built into Pegasus. See the build documentation about how to rebuild the program. There's also a file called translations.qrc.in in the translations repository which lists the language files. It's another XML file that you can open in a text editor; simply add a new file pegasus_LOCALECODE.qm /file entry (note the QM extension!). Note This step is only required for trying out the translation in-app. You can safely skip it if you don't want to deal with building Pegasus. 5. Open a pull request If you know Git, open a pull request in the translations repository . Alternatively, open a new issue and attach your translation (TS) file.","title":"Translations"},{"location":"dev/translate/#translations","text":"Pegasus supports most languages in use today, and you can easily add new translations for any locale. The translations are stored in simple text files in XML format, so the only thing you need is a text editor. There's also a graphical tool to make things easier (see below). The translations themselves are collected in a separate repository here , which is also included as a Git submodule in the main Pegasus repo. In short (optional) download the Qt tools download the translation repo create a copy of pegasus_en.ts for your language open the new file in Qt Linguist or your editor of choice, and translate the strings open a new issue in the translation repo and attach your TS file Todo In the future, there'll be likely some kind of online site for managing translations.","title":"Translations"},{"location":"dev/translate/#file-format-and-name","text":"The translation files are text files in XML format, encoded in UTF-8. Their file name includes the BCP47 language tag of the locale the they're made for. Usually this means the following structure: pegasus_[language][-script][-country].ts where language is the language code, mentioned above. Two- or rarely three letters, lowercase. optionally, script defines the writing system, like simplified/traditional chinese or Old German Runes. Four letters, title case. optionally, country defines regional settings, which affects things like date format, usually. Two letters, uppercase. for example, hi-Deva-IN means Hindi language, Devanagari script, and the regional settings of India. Usually though the two letter language code is enough for most locales. Two letter language codes can be found here , and four letter script codes here .","title":"File format and name"},{"location":"dev/translate/#1-preparing-the-tools","text":"You can use any decent text editor to edit the files. There's also a graphical translation tool called Qt Linguist : Qt Linguist is included with Qt, see here . After installation, search for linguist in the installation directory of Qt (Linux) or the Start menu (Windows).","title":"1. Preparing the tools"},{"location":"dev/translate/#2-prepare-the-translation-files","text":"You can find the translation files in this repository . If you have no experience with Git, just click on the green Clone or download button, then Download ZIP . Then, create a copy of pegasus_en.ts , and change en to your locale's code (see above). Developer note You can create this file with lupdate ../src -ts pegasus_en.ts -no-obsolete .","title":"2. Prepare the translation files"},{"location":"dev/translate/#3-translate-the-file","text":"Open your new file in a text editor or in Qt Linguist. If you're using a text editor , the translateable strings are inside message tags: you can see the original text in the source tag, and you can provide your translation in translation . Also change the language tag on the top of the file ( TS ... ). If you're using Qt Linguist , first set your language in Edit - Translation file settings - Target language . After that, you can select a \"module\" (group of texts) on the left, then see the relevant strings in the upper-middle panel. You can add the translation in the center panel (marked with \"1\" on the picture above). Then press the green checkmark on the top toolbar (or press Ctrl+Enter) to jump to the next untranslated line. A detailed guide for Qt Linguist can be found here . Help %1 , %2 , ... in the text is a placeholder for additional values, such as numbers, file names, etc. screenshots for most of the translateable text can be found here","title":"3. Translate the file"},{"location":"dev/translate/#4-optional-rebuild-pegasus-and-test-the-translation","text":"At the moment, all translation files must be built into Pegasus. See the build documentation about how to rebuild the program. There's also a file called translations.qrc.in in the translations repository which lists the language files. It's another XML file that you can open in a text editor; simply add a new file pegasus_LOCALECODE.qm /file entry (note the QM extension!). Note This step is only required for trying out the translation in-app. You can safely skip it if you don't want to deal with building Pegasus.","title":"4. (optional) Rebuild Pegasus and test the translation"},{"location":"dev/translate/#5-open-a-pull-request","text":"If you know Git, open a pull request in the translations repository . Alternatively, open a new issue and attach your translation (TS) file.","title":"5. Open a pull request"},{"location":"themes/api/","text":"API reference (alpha) All data provided by Pegasus can be accessed using a global QML object called api . It has the following main components: api.collections : the list of all collections api.allGames : the list of all games api.keys : the keyboard/gamepad configuration of the user api.memory : an object that can store theme specific settings Collections Games found by Pegasus are organized in collections, and one game may be present in multiple collections. The collections can be accessed trough api.collections , which is an item model (in short, a list of items). Each collection in it has the following properties: Property Description name The unique name of the collection, eg. \"Nintendo Entertainment System\", \"Mario Cartridges\", etc. shortName A short name for the collection, often an abbreviation like nes , mame , etc. Always in lowercase. If not set, defaults to the value of name . summary Short description (typically 2-3 sentences). description Longer description. games The list of games belonging to this collection; see \"Games\" below. All available collections are guaranteed to have at least one game. assets An object containing the default assets (see later). Properties marked as \"optional\" might have no value (eg. empty string or empty array). All fields are read-only. Games Games can have metadata and various kinds of assets. The list of games belonging to a collection can be accessed using a collection's games field (see above). The list of all available games can be accessed through api.allGames . Both are item models . Each game in them has the following properties: Property Description title The game's title developer Developer(s) as a string. If there are more than one, they are separated with , . publisher Publisher(s) as a string. If there are more than one, they are separated with , . genre Genre(s) as a string. If there are more than one, they are separated with , . developerList The list of developers as an array. publisherList The list of publishers as an array. genreList The list of genres as an array. summary Short description (typically 2-3 sentences). description Longer description. release Release date as QML date . If not set, defaults to an invalid date. releaseYear Release year as integer. Defaults to 0. releaseMonth Release month as integer. Defaults to 0. releaseDay Release day as integer. Defaults to 0. players Maximum number of players. If not set, defaults to 1. rating Floating-point value between and including 0.0 and 1.0 (ie. 0% and 100%). If not set, defaults to 0.0 . favorite Boolean (true/false) value. If not set, defaults to false. This field is writable . playCount The number of times this games was launched. Defaults to 0. lastPlayed The last time this game was launched. A QML date value with time information. Defaults to an invalid date. playTime Play time in seconds, as a positive integer value. Defaults to 0. files An object containing the game's launchable files (see below). assets An object containing the game's assets (see later). Properties marked as \"optional\" might have no value (eg. empty string or empty array). Unless otherwise noted, all fields are read-only. In addition, games have the following callable methods: Method Description launch() Launch this game. If the game has more than one launchable file, the default file selector of Pegasus will appear. Game files Experimental This section is experimental and may change in the future. Games can have more than one file to launch (disks, clones, mods, etc). Every game has a files object that contains the files belonging to the game. It has the following properties: Property Description name The pretty name of this file. path The path to this file. playCount The number of times this file was launched. Defaults to 0. lastPlayed The last time this file was launched. A QML date value with time information. Defaults to an invalid date. playTime Play time in seconds, as a positive integer value. Defaults to 0. Note At the moment name comes from the filename of the file. In the future, this could be set in the metadata format. In addition, games have the following callable methods: Method Description launch() Launch this game file. Launching a game file may fail, in which case the reason is logged (and in the future, will be shown to the user). If the game starts up successfully, Pegasus minimizes its resource usage and goes to the background while the game runs. On return, the theme will be reloaded -- if you wish it to remember something, you can use api.memory (see later on this page). Assets Every game and collection has an asset object that contains the assets that may belong to a game. It has the following properties. All of them are (local or remote) URLs as string, and all of them can be empty. Property Description boxFront The front of the game box boxBack The back of the game box boxSpine The spine (side) of the game box boxFull Full size box art (front + back + spine) cartridge Image of the game medium (cartridge, floppy, disk, etc.) logo The game's logo, usually the title art over a transparent background Property Description marquee A wide (often over 3:1) artwork on the top of arcade machines bezel Decoration around a game's screen on an arcade machine or emulator panel Control panel of the arcade machine cabinetLeft Left side of the arcade machine cabinetRight Right side of the arcade machine Property Description tile A square-sized image ( not the desktop icon) banner An image in 16:9 aspect ratio steam Steam grid icon, 460:215 ratio (most often 460x215, some people use 920x430) poster Advertisement poster, usually with 2:3 aspect ratio (in general a portrait-aligned image) background A background image, eg. artwork or selected screenshot music Background music In addition, the following members can have multiple values, and as such usable as eg. model sources. All of them can be empty. Property Description screenshots Array of strings, each a URL to an image. videos Array of strings, each a URL to a video source. Keys Controls configuration can be queried using the api.keys object, with the functions and members below. For each UI functionality (eg. \"accept\"), you can check whether a particular key/button is registered to that event, or get all of the registered keys as an array. Purpose Check function Array accept/select isAccept(keyevent) accept cancel/back isCancel(keyevent) cancel details isDetails(keyevent) details filters isFilters(keyevent) filters next page isNextPage(keyevent) nextPage previous page isPrevPage(keyevent) prevPage page up isPageUp(keyevent) pageUp page down isPageDown(keyevent) pageDown In themes, you typically handle keyboard and gamepad key presses/releases using Keys.onPressed and Keys.onReleased (see the Qt documentation ). The event object you receive there can be used as the parameter for the functions above. As for the key list querying, the returned array contains simple objects that have key and modifiers fields, like the real QML KeyEvent object (but nothing else). Example: Keys.onPressed: { if ( api . keys . isAccept ( event )) { event . accepted = true ; // do something } } Warning For regular navigation (ie. up/down/left/right), the QML KeyNavigation can be used (documentation here ). Navigation keys (arrows/dpad/left stick) cannot be changed at the moment. Memory Themes often want to remember data like custom options or the index of the last launched game or collection. To store the settings belonging to your theme, you can use api.memory . This is an object that contains key-value pairs (like a Map), and can be modified using the following methods: Method Description set(key, value) Sets the value belonging to key . If key already exists, its value will be overwritten. get(key) Returns the value belonging to key , if there is any, otherwise returns undefined . has(key) Returns true if key is set (has value), otherwise returns false. unset(key) Removes key and its value. key must be a string in all methods above, while value can be any JSON-compatible JavaScript type. Good places to use api.memory for example is when your theme loads ( Component.onCompleted ), unloads ( Component.onDestruction ) or the user starts a game. For example: ListView { id: mygamelist model: api . allGames delegate: Rectangle { MouseArea { anchors.fill: parent onClicked: launchGame ( modelData ) } } } Component.onCompleted: { mygamelist . currentIndex = api . memory . get ( gameIndex ) || 0 ; } function launchGame ( game ) { api . memory . set ( gameIndex , mygamelist . currentIndex ); game . launch (); } Theme utilities Item models Item models are list of objects that support custom sorting and filtering, and can be used as the model property of QML Views (eg. ListView or PathView). See the Qt documentation for more details. For convenience, the modelData role is also provided for all item models mentioned in this documentation. Sometimes you may want to access the items of an item model manually. To query the number of items in the model, you can check its count property (eg. api.allGames.count ), while to get a single item of it, you can use the get(index) method (eg. api.allGames.get(5) ). Sorting and filtering Item models can be sorted and filtered using SortFilterProxyModel . Please see the samples in the linked documentation for usage tips. The list of all available sorters and filters can be found here . For example, to get the list of all games ordered by play time, you could write a code similar to this: import SortFilterProxyModel 0.2 ... SortFilterProxyModel { id: mysorter sourceModel: api . allGames sorters: RoleSorter { roleName: playTime } } ListView { model: mysorter ... } Fonts Pegasus comes with a sans-serif and a sans-serif condensed font face, which are used in the main menu. If you want to use the same font families in your theme, you can access them using a global QML object called globalFonts . This has the following properties: Property Description sans The sans-serif font condensed The sans-serif condensed font You can use them as the value for font.family members of Text items, eg. font.family: globalFonts.sans . The fonts currently in use are Roboto and Roboto Condensed.","title":"API reference"},{"location":"themes/api/#api-reference-alpha","text":"All data provided by Pegasus can be accessed using a global QML object called api . It has the following main components: api.collections : the list of all collections api.allGames : the list of all games api.keys : the keyboard/gamepad configuration of the user api.memory : an object that can store theme specific settings","title":"API reference (alpha)"},{"location":"themes/api/#collections","text":"Games found by Pegasus are organized in collections, and one game may be present in multiple collections. The collections can be accessed trough api.collections , which is an item model (in short, a list of items). Each collection in it has the following properties: Property Description name The unique name of the collection, eg. \"Nintendo Entertainment System\", \"Mario Cartridges\", etc. shortName A short name for the collection, often an abbreviation like nes , mame , etc. Always in lowercase. If not set, defaults to the value of name . summary Short description (typically 2-3 sentences). description Longer description. games The list of games belonging to this collection; see \"Games\" below. All available collections are guaranteed to have at least one game. assets An object containing the default assets (see later). Properties marked as \"optional\" might have no value (eg. empty string or empty array). All fields are read-only.","title":"Collections"},{"location":"themes/api/#games","text":"Games can have metadata and various kinds of assets. The list of games belonging to a collection can be accessed using a collection's games field (see above). The list of all available games can be accessed through api.allGames . Both are item models . Each game in them has the following properties: Property Description title The game's title developer Developer(s) as a string. If there are more than one, they are separated with , . publisher Publisher(s) as a string. If there are more than one, they are separated with , . genre Genre(s) as a string. If there are more than one, they are separated with , . developerList The list of developers as an array. publisherList The list of publishers as an array. genreList The list of genres as an array. summary Short description (typically 2-3 sentences). description Longer description. release Release date as QML date . If not set, defaults to an invalid date. releaseYear Release year as integer. Defaults to 0. releaseMonth Release month as integer. Defaults to 0. releaseDay Release day as integer. Defaults to 0. players Maximum number of players. If not set, defaults to 1. rating Floating-point value between and including 0.0 and 1.0 (ie. 0% and 100%). If not set, defaults to 0.0 . favorite Boolean (true/false) value. If not set, defaults to false. This field is writable . playCount The number of times this games was launched. Defaults to 0. lastPlayed The last time this game was launched. A QML date value with time information. Defaults to an invalid date. playTime Play time in seconds, as a positive integer value. Defaults to 0. files An object containing the game's launchable files (see below). assets An object containing the game's assets (see later). Properties marked as \"optional\" might have no value (eg. empty string or empty array). Unless otherwise noted, all fields are read-only. In addition, games have the following callable methods: Method Description launch() Launch this game. If the game has more than one launchable file, the default file selector of Pegasus will appear.","title":"Games"},{"location":"themes/api/#game-files","text":"Experimental This section is experimental and may change in the future. Games can have more than one file to launch (disks, clones, mods, etc). Every game has a files object that contains the files belonging to the game. It has the following properties: Property Description name The pretty name of this file. path The path to this file. playCount The number of times this file was launched. Defaults to 0. lastPlayed The last time this file was launched. A QML date value with time information. Defaults to an invalid date. playTime Play time in seconds, as a positive integer value. Defaults to 0. Note At the moment name comes from the filename of the file. In the future, this could be set in the metadata format. In addition, games have the following callable methods: Method Description launch() Launch this game file. Launching a game file may fail, in which case the reason is logged (and in the future, will be shown to the user). If the game starts up successfully, Pegasus minimizes its resource usage and goes to the background while the game runs. On return, the theme will be reloaded -- if you wish it to remember something, you can use api.memory (see later on this page).","title":"Game files"},{"location":"themes/api/#assets","text":"Every game and collection has an asset object that contains the assets that may belong to a game. It has the following properties. All of them are (local or remote) URLs as string, and all of them can be empty. Property Description boxFront The front of the game box boxBack The back of the game box boxSpine The spine (side) of the game box boxFull Full size box art (front + back + spine) cartridge Image of the game medium (cartridge, floppy, disk, etc.) logo The game's logo, usually the title art over a transparent background Property Description marquee A wide (often over 3:1) artwork on the top of arcade machines bezel Decoration around a game's screen on an arcade machine or emulator panel Control panel of the arcade machine cabinetLeft Left side of the arcade machine cabinetRight Right side of the arcade machine Property Description tile A square-sized image ( not the desktop icon) banner An image in 16:9 aspect ratio steam Steam grid icon, 460:215 ratio (most often 460x215, some people use 920x430) poster Advertisement poster, usually with 2:3 aspect ratio (in general a portrait-aligned image) background A background image, eg. artwork or selected screenshot music Background music In addition, the following members can have multiple values, and as such usable as eg. model sources. All of them can be empty. Property Description screenshots Array of strings, each a URL to an image. videos Array of strings, each a URL to a video source.","title":"Assets"},{"location":"themes/api/#keys","text":"Controls configuration can be queried using the api.keys object, with the functions and members below. For each UI functionality (eg. \"accept\"), you can check whether a particular key/button is registered to that event, or get all of the registered keys as an array. Purpose Check function Array accept/select isAccept(keyevent) accept cancel/back isCancel(keyevent) cancel details isDetails(keyevent) details filters isFilters(keyevent) filters next page isNextPage(keyevent) nextPage previous page isPrevPage(keyevent) prevPage page up isPageUp(keyevent) pageUp page down isPageDown(keyevent) pageDown In themes, you typically handle keyboard and gamepad key presses/releases using Keys.onPressed and Keys.onReleased (see the Qt documentation ). The event object you receive there can be used as the parameter for the functions above. As for the key list querying, the returned array contains simple objects that have key and modifiers fields, like the real QML KeyEvent object (but nothing else). Example: Keys.onPressed: { if ( api . keys . isAccept ( event )) { event . accepted = true ; // do something } } Warning For regular navigation (ie. up/down/left/right), the QML KeyNavigation can be used (documentation here ). Navigation keys (arrows/dpad/left stick) cannot be changed at the moment.","title":"Keys"},{"location":"themes/api/#memory","text":"Themes often want to remember data like custom options or the index of the last launched game or collection. To store the settings belonging to your theme, you can use api.memory . This is an object that contains key-value pairs (like a Map), and can be modified using the following methods: Method Description set(key, value) Sets the value belonging to key . If key already exists, its value will be overwritten. get(key) Returns the value belonging to key , if there is any, otherwise returns undefined . has(key) Returns true if key is set (has value), otherwise returns false. unset(key) Removes key and its value. key must be a string in all methods above, while value can be any JSON-compatible JavaScript type. Good places to use api.memory for example is when your theme loads ( Component.onCompleted ), unloads ( Component.onDestruction ) or the user starts a game. For example: ListView { id: mygamelist model: api . allGames delegate: Rectangle { MouseArea { anchors.fill: parent onClicked: launchGame ( modelData ) } } } Component.onCompleted: { mygamelist . currentIndex = api . memory . get ( gameIndex ) || 0 ; } function launchGame ( game ) { api . memory . set ( gameIndex , mygamelist . currentIndex ); game . launch (); }","title":"Memory"},{"location":"themes/api/#theme-utilities","text":"","title":"Theme utilities"},{"location":"themes/api/#item-models","text":"Item models are list of objects that support custom sorting and filtering, and can be used as the model property of QML Views (eg. ListView or PathView). See the Qt documentation for more details. For convenience, the modelData role is also provided for all item models mentioned in this documentation. Sometimes you may want to access the items of an item model manually. To query the number of items in the model, you can check its count property (eg. api.allGames.count ), while to get a single item of it, you can use the get(index) method (eg. api.allGames.get(5) ).","title":"Item models"},{"location":"themes/api/#sorting-and-filtering","text":"Item models can be sorted and filtered using SortFilterProxyModel . Please see the samples in the linked documentation for usage tips. The list of all available sorters and filters can be found here . For example, to get the list of all games ordered by play time, you could write a code similar to this: import SortFilterProxyModel 0.2 ... SortFilterProxyModel { id: mysorter sourceModel: api . allGames sorters: RoleSorter { roleName: playTime } } ListView { model: mysorter ... }","title":"Sorting and filtering"},{"location":"themes/api/#fonts","text":"Pegasus comes with a sans-serif and a sans-serif condensed font face, which are used in the main menu. If you want to use the same font families in your theme, you can access them using a global QML object called globalFonts . This has the following properties: Property Description sans The sans-serif font condensed The sans-serif condensed font You can use them as the value for font.family members of Text items, eg. font.family: globalFonts.sans . The fonts currently in use are Roboto and Roboto Condensed.","title":"Fonts"},{"location":"themes/example-flixnet/","text":"Warning This tutorial is a bit outdated. Certain API commands have changed, so the code blocks below may not work out of the box. However the general ideas still hold, so this might be useful for learning QML itself. Step-by-step: Flixnet theme In this tutorial, we'll implement the theme above from scratch, inspired by the UI of a certain video streaming company. While the guide is intended to be beginner-friendly, this is a somewhat complex project, so you might want to be familiar with the QML basics and dynamic layout elements (see the QML tutorials ). If we simplify it a bit, here's how its structure and navigation looks like: As you can see, there are two main axes of motion: a horizontal game axis for each collection's games a vertical collection axis for selecting a collection Each row can be individually scrolled, and the currently selected game is the topmost row's first (fully visible) item. Furthermore, the rows themselves can also be scrolled vertically. This kind of layout makes the theme a bit complex, but other than these axes the rest of the theme seems to be simple enough. Let's get started! Initial files I'm on Linux, so my theme directory is at ~/.config/pegasus-frontend/themes . I'm creating a new directory called flixnet-tutorial , and in it my theme.cfg , like this: name : Flixnet tutorial author : M\u00e1ty\u00e1s Mustoha and the basic theme.qml : import QtQuick 2.0 FocusScope { } Now I open Pegasus and select this theme on the Settings screen. I'll keep Pegasus open during the development, and refresh the theme with the F5 key. I also open the main log file ~/.config/pegasus-frontend/lastrun.log which will tell me if I've made any errors in the QML file. Tip You can use whatever text editor you like. Qt Creator is cross platform, has good auto-complete and syntax highlight features. For a more lightweight editor, Sublime Text with the QML package, Atom or Notepad++ could be used, among others. Note You might see .qmlc files popping up in your theme's directory. These are cache files, generated for faster loading. When copying the theme to a different machine, you don't have to bring them, they'll automatically get generated the next time you launch Pegasus. Initial layout Let's start with the hard part, the layout on the bottom half. This is a vertically scrollable list of horizontally scrollable lists, each containing boxes for the games. Because collections are what contain the games, I'll first start making the vertical axis that selects the collection, and then add the horizontal game selection after that. I'll write a rough initial structure first, as once you have the basic layout done, you can tweak the elements as much as you want. Some planning The game selection layout will take the whole lower half of the screen. On a standard 16:9 screen I want to show 2 rows of games to appear, and incrementally more on screens with smaller aspect ratios. Using Pegasus' virtual pixel values, I can design the theme for a screen with at least 720px height, and the values will scale appropriately for other resolutions. Based on that, if the height of the list is half the screen's height, I'll have 360px at least if I want to show two rows, one row's full height in the list will be 180px I'll use 18px font size for the collection's name to have some space around the text, I'll use 250% line height; that's 45px out of the 180px so far I'm left with 135px height to use for the game boxes the game boxes will have a 16:9 aspect ratio, so their width will be 240px Ok, let's start coding! Vertical axis A simple type for laying out a variable amount of items with one of them being selected is ListView . I set it up so it takes the whole lower half of the screen: import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom } } One element of this collection axis will have 180px height and the width is the whole width of the screen. I'll create a placeholder for now and add a fake model (a series of numbers) for testing (so you can see that they indeed come in order, and the ListView has the correct amount of items): import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: 10 // just some random number delegate: Rectangle { width: ListView . view . width height: vpx ( 180 ) color: blue } } } If you now refresh Pegasus, you'll see the lower half of the screen turned blue. Yay! vpx The function vpx is what you can use for virtual pixel values. It scales up or down the pixel value you put into it depending on the actual screen resolution. delegate The visual element of a list is called delegate . For every data item of the model (in this case, for every number between 0 and 9), a delegate will be created. The code looks good so far, I'll just make a small change: the delegate will likely get more complex later, so to make it easier to read, I'll move it out into a separate Component : import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: 10 delegate: collectionAxisDelegate } Component { id: collectionAxisDelegate Rectangle { width: ListView . view . width height: vpx ( 180 ) color: blue } } } Tip Component is a special element that defines a QML document. Actually, you could even move the Rectangle to a new file (eg. CollectionAxisDelegate.qml ) and use the file's name to set the delegate (eg. delegate: CollectionAxisDelegate { } ). Horizontal axis The rows of the collection axis will consist of two things: a Text label that shows the collection's name and a ListView that shows its games. Because a Component can have only one child, I'll turn the Rectangle into an Item (an otherwise invisible container), and put a Text and a ListView into it. Note Just as individual QML files can have only one root element, Component can have only one child. First I'll add the collection label: import QtQuick 2.0 FocusScope { ListView { id: collectionAxis // ... } Component { id: collectionAxisDelegate Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label // `modelData` is the item in the list s model // for which this delegate is created for; // in this case a number between 0-9 text: modelData // white, bold 18px font, using Pegasus default font family color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans font.bold: true // make the line height 45px high // and center the text vertically in it height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter } } } } If you refresh the theme in Pegasus, you'll now see the numbers \"0\" and \"1\" at where we'd expect the labels. I'll now add the horizontal ListView : Component { id: collectionAxisDelegate Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label // ... } ListView { id: gameAxis // span from left to right, from the label s bottom to the row s bottom anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom // this one goes horizontal! orientation: ListView . Horizontal } } } We'll need a model and a delegate item to actually see something. Let's create some dummy items: import QtQuick 2.0 FocusScope { // ... Component { id: collectionAxisDelegate Item { // ... ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: 20 delegate: gameAxisDelegate spacing: vpx ( 10 ) // some spacing to make it look fancy } } } // this is one item of the horizontal axis, ie. a game box Component { id: gameAxisDelegate Rectangle { // as we calculated previously width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { // will become a number between 0-19 text: modelData } } } } And here's how it should look so far: Not the most beautiful yet, however with this we're done with the basics of the main layout. From now on we'll just have tweak these lists and delegates, then add some simple components for the metadata. The code so far #1 Here's the whole code so far (without comments to save space): The code so far #1 import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: 10 delegate: collectionAxisDelegate } Component { id: collectionAxisDelegate Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label text: modelData color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter } ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: 20 delegate: gameAxisDelegate spacing: vpx ( 10 ) } } } Component { id: gameAxisDelegate Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { text: modelData } } } } Navigation You might have noticed that the components react already to mouse drag or scroll, but keyboard and gamepad input doesn't work yet. Let's fix this. Vertical scroll Simply add focus: true to the collection axis: ListView { id: collectionAxis // ... focus: true } You can now scroll the bars with Up and Down , but... it's kind of weird right now. It'd be better for the items to \"snap\" to their place, to scroll to the next item when we press a button. This can be fixed with the snapMode and highlightRangeMode properties: setting snapMode keeps the elements organized when scrolling the list as a whole, while highlightRangeMode will make sure the selection follows the scrolling (that is, when you press Up or Down , you actually select the next or previous element, not just view a different part of the list). ListView { id: collectionAxis // ... snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange focus: true } There, much better now. Tip Setting up the keyboard input also makes gamepads work. Check the Controls page to see how are they related. By default, every delegate that is at least partially in the ListView's area is fully drawn. To make sure only the rows in the lower half of the screen are visible, I set clip on the ListView : ListView { id: collectionAxis // ... snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange clip: true focus: true } Horizontal scroll We have a somewhat complex layout -- scrollable items inside a scrollable item; we can't just set focus: true here, since that'd mean we set it for each row, and end up with scrolling one we don't want. Hovewer, every ListView has select-next and select-previous function we can use ( incrementCurrentIndex() , decrementCurrentIndex() ), and the currently selected item can be accessed through currentItem . In this case, the currentItem of collectionAxis will be the Item element inside collectionAxisDelegate : Component { id: collectionAxisDelegate // this one! Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label // ... } ListView { id: gameAxis // ... } } } But how can we access the ListView, gameAxis of the Item? Turns out we can't just use its id , as it's not accessible by external element (we'll get an error about gameAxis being undefined). Function definitions and property members, however, can be accessed. For now, I'll simply create an alias property for the horizontal axis: Component { id: collectionAxisDelegate Item { property alias axis: gameAxis width: ListView . view . width height: vpx ( 180 ) Text { id: label // ... } ListView { id: gameAxis // ... } } } We can now access the game axis of the current collection as currentItem.axis (see below). Note Yes, you can also write it like property alias gameAxis: gameAxis , I simply preferred the different name in this case. Combining the ListView functions, currentItem and manual keyboard handling ( Keys ), we can now make the horizontal scrolling work with: ListView { id: collectionAxis // ... focus: true Keys.onLeftPressed: currentItem . axis . decrementCurrentIndex () Keys.onRightPressed: currentItem . axis . incrementCurrentIndex () } ...which, similarly to the vertical axis, initially scrolls in a not so nice way. Fix it like previously, but in the delegate: ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: 100 delegate: gameAxisDelegate spacing: vpx ( 10 ) snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange } And now both directions should scroll finely! Tip To see that the current item indeed changes, you could set the color of the gameAxisDelegate 's Rectangle to: color: ListView . isCurrentItem ? orange : green Left margin There's a small margin on the left that shows the game before the currently selected one. We don't want to reduce the size of the horizontal ListView s (they should fill the whole width of the screen), we just want to move the currently selected item a little bit right. For this, we can use the preferredHighlightBegin / End members of the ListView s: they can be used to define a fixed position range (in pixels) where the currently selected element should reside. I'll set a 100px offset like this: ListView { id: gameAxis // ... preferredHighlightBegin: vpx ( 100 ) preferredHighlightEnd: preferredHighlightBegin + vpx ( 240 ) // the width of one game box } Help preferredHighlightBegin and preferredHighlightEnd almost always come in pair, and End must be greater or equal than Begin to have their effect applied. We also need to move the collection label too. As it's just a regular Text element, I'll simply set its left anchor and a margin on it: Component { id: collectionAxisDelegate Item { // ... Text { id: label // ... anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } ListView { id: gameAxis // ... } } } Note The anchor margin is only applied if the anchor itself is defined. Tip You can also use the Text item's leftPadding property. This feature was added in Qt 5.6 (as mentioned in the official documentation ), so you'll need to change the import command on the top of the QML file to import QtQuick 2.6 or higher (Pegasus comes with Qt 5.9 at the moment). Using API data Finally, the time has come to replace the placeholder elements with actual content. Let's start by using the real collection data. According to the API reference , collections can be accessed and selected through api.collectionList : we can use api.collectionList.model as the model of a ListView (or any other View) and index as the currentIndex of it. We can then call increaseIndex() and decreaseIndex() to move to the next and previous items (or by setting the index manually). Vertical axis First, find the ListView for the collection axis and set its model property. Then add the currentIndex line to bind it to the index from the API. Finally, call increaseIndex() and decreaseIndex() when Up and Down is pressed: ListView { id: collectionAxis // ... model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate // ... focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . axis . decrementCurrentIndex () Keys.onRightPressed: currentItem . axis . incrementCurrentIndex () } Warning Incrementing/decrementing the currentIndex property of a ListView (eg. by navigation) has no effect on the bound value (in this case api.collectionList.index ); this is why I call incrementIndex() / decrementIndex() manually on Up and Down . We'll also modify the Left / Right keys very soon. Tip Instead of using Keys and increment/decrement, you can also set api.collectionList.index manually, eg. onCurrentIndexChanged: api . collectionList . index = currentIndex Help incrementIndex() and decrementIndex() wraps around (incrementing the index at the last item will make it jump to the first one). If you don't want them to wrap, you can use incrementIndexNoWrap() and decrementIndexNoWrap() instead. Previously the model was set to 10 , and so the modelData available in the delegates was a number between 0 and 9. With model set to api.collectionList.model , the modelData will be a Collection object. A Collection always has a name , so let's show that: Component { id: collectionAxisDelegate Item { // ... Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans // ... } ListView { id: gameAxis // ... } } } Tip If the name of the modelData property you use (in this case name ) don't collide with other properties of the object, it's not required to type out modelData : you can simply write text: name . After a refresh, you should see the names of collections appearing in Pegasus. Horizontal axis Now let's show the game titles in the horizontal rectangles. Every Collection has a gameList member we can use to access the list of games associated with the collection. Similarly to collectionList , gameList also has model and index properties, so let's use them in the horizontal axis ( collectionAxisDelegate ): Component { id: collectionAxisDelegate Item { // ... Text { id: label // ... } ListView { id: gameAxis // ... model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate spacing: vpx ( 10 ) // ... } } } Just like with the vertical axis, I'll use incrementIndex() and decrementIndex() again. Currently we access the horizontal ListView of the collection delegate via an alias property, and call the ListView's incrementCurrentIndex() and decrementCurrentIndex() methods by Keys.onLeftPressed and Keys.onRightPressed of the collection axis. Instead, we should call the index changing functions of the API, of the Collection belonging to a delegate (ie. modelData ). As usual, there are more than one way to do it, I'll show how you can use JavaScript functions this time. First, find the property alias axis: gameAxis line Component { id: collectionAxisDelegate Item { property alias axis: gameAxis // this one // ... Text { ... } ListView { ... } } } then delete and replace it with the selectNext() and selectPrev() functions, with the increment/decrement methods of the API in their body: Component { id: collectionAxisDelegate Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } // ... Text { ... } ListView { ... } } } Then you can call the new functions in the collectionAxis like this: ListView { id: collectionAxis // ... model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate // ... focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () } And now the Views scroll properly, with the real data! Game items With the previous changes, gameAxisDelegate is now a visual representation for a Game element. A Game always has a title , so we can simply set it as the text: Component { id: gameAxisDelegate Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { text: modelData . title } } } Help The model of the vertical ListView was a list of Collection s, so the modelData received by a delegate of that ListView (one whole horizontal row) is one Collection object. The model of these horizontal ListViews is a list of Game s, so a delegate of the horizontal ListViews will see a Game in its modelData . And now the game names also show up in Pegasus: Launching games Now that the game selection items are in sync with the API, we can actually launch games! To start the currently selected game, simply call api.currentGame.launch() when Enter is pressed: ListView { id: collectionAxis // ... focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Help Careful not to confuse the onReturnPressed and onEnterPressed calls: technically Return is the key next to the letters, while Enter is the one on the numeric keypad. Note onReturnPressed is also triggered by pressing / on the gamepad. And with this, technically our theme is fully functional! Next step, let's make it pretty. The code so far #2 The code so far #2 import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange clip: true focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Component { id: collectionAxisDelegate Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } width: ListView . view . width height: vpx ( 180 ) Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate spacing: vpx ( 10 ) snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange preferredHighlightBegin: vpx ( 100 ) preferredHighlightEnd: preferredHighlightBegin + vpx ( 240 ) } } } Component { id: gameAxisDelegate Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { text: modelData . title } } } } Fancy game boxes I'll now replace the green game boxes with something better to look at. There are two main cases we have to support: if there is an available image for a game, the box should show that if there is none, or the image has not loaded yet, the box should show a gray rectangle, with the game's title in the center So gameAxisDelegate is our game box that right now contains a green rectangle. I'll turn that into an Item, and, for the two cases above, I'll add an initial gray Rectangle and Image: Component { id: gameAxisDelegate Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 } Image { id: image anchors.fill: parent } } } So which image asset should we use? A game box is a rectangle with 16:9 aspect ratio, so the banner would be perfect for this. However, since every asset is potentially missing, we should consider showing other images and provide multiple fallbacks. If we don't have a banner , the next similarly sized one is the steam (\"grid icon\") asset. Because it's wider than 16:9, we'll need to crop it if we don't want black bars or squashed/scretched images (though you might prefer that). If neither image is available, I'll use boxFront as it tends to be commonly available. Let's extend the Image object created previously: Image { id: image anchors.fill: parent visible: source // fill the whole area, cropping what lies outside fillMode: Image . PreserveAspectCrop asynchronous: true source: assets . banner || assets . steam || assets . boxFront sourceSize { width: 256 ; height: 256 } } I've also made some optimizations here: I've set asynchronous: true : Loading image files takes some time depending on the device Pegasus runs on. If this property is set to false (default), the program will not react to input until the image is loaded (or noticed that it failed to load). If it's false, the image is loaded \"in the background\", and input is not blocked; hovewer depending on your theme, you might want to show something in its place for the users during this time (eg. a loading spinner or progress bar). I've set sourceSize : This sets the maximum size the image should occupy in the memory. The official documentation describes this in detail. I've set visible: source , that is, if the source is empty (neither banner , steam or boxFront is available), then ignore this whole object: no input will be ever handled here and there's nothing to see either. With these changes, here's how it looks: Starting to take shape, isn't it? Let's finish the text-only fallback too: Component { id: gameAxisDelegate Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 visible: image . status !== Image . Ready Text { text: modelData . title // define the text area anchors.fill: parent anchors.margins: vpx ( 12 ) // align to the center horizontalAlignment: Text . AlignHCenter verticalAlignment: Text . AlignVCenter wrapMode: Text . Wrap // set the font color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Image { id: image // ... } } } And we're done with the game boxes! Looping the axes It'd be nice if all of the lists would loop around. You can do two kinds of loop: make the list finite and when the last item is reached, jump back to the first one (and also in reverse direction) make the list infinite and loop around (carousel style) The first one can be done either by simply setting keyNavigationWraps: true for a ListView (and other Views) or using the API's default index increase/decrease functions. In our case though, the carousel option would look the best. I won't lie, making a carousel-like looping list is annoying and overly complex for this use case; the situation might improve later by creating some easier-to-use custom types in Pegasus. Vertically So the problem is, ListView can't do carousels: the only type that can is PathView. As such, we'll turn our ListViews into PathViews next. Again, let's start with the vertical axis; here's a before-after comparison, with some comments after the code: Before ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange clip: true focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } After PathView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate // changed ListView to PathView snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange clip: true // brand new: path definitions pathItemCount: 1 + Math . ceil ( height / vpx ( 180 )) path: Path { startX: collectionAxis . width * 0.5 startY: vpx ( 180 ) * - 0.5 PathLine { x: collectionAxis . path . startX y: collectionAxis . path . startY + collectionAxis . pathItemCount * vpx ( 180 ) } } preferredHighlightBegin: 1 / pathItemCount preferredHighlightEnd: preferredHighlightBegin focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Warning Don't forget to change ListView to PathView in the delegate ( collectionAxisDelegate 's width prop) too! Unlike ListView that goes to one direction only, PathView can be used to create arbitrary paths on which the items will travel (curves, circles, all kinds of shapes). Because of that, some properties have to be provided in percentage or need manual calculations. For PathViews, pathItemCount must be set (the default behaviour is to show all items). We should show as many rows as it fits into lower half or the screen (one row's height is 180px). The number of visible items thus will be [area height] / [row height], which I've rounded up using Math.ceil , a standard JavaScript function. However, when there's a scrolling going on, there'll be actually one more row visible on the screen: the topmost row will gradually go out on the top of the lower area, while a new line is on its way in to appear on the bottom (see the animation below). The path defines the trail the elements will follow by their center point . Because there'll be one item that slides out , and one that slides in , the path extends above and below the PathView's area. The starting point of the axis (the center point of the item that will slide out) is horizontally ( startX ) the center of the screen (as the rows fill the width), and vertically ( startY ) above the top edge of the PathView (which would be 0) by 50% of the row height (where values are in pixels). From the start point, a linear path is created with PathLine : I've set it so the end point is the same as the start except the Y coordinate, which is increased by the length ot the path, [number of max. visible items] * [item height]. The preferred highlight positions are in percentage for the PathView (as it can have any kind of shape, pixels don't always make sense). Again, the values define the range for the center point of the selected item. It defaults to 0 (start of the line), which in our case would be the center of the sliding out element, out of the visible area. I've set it to [1] / [item count], which will produce the center point of the second element on the path. Since I'm not planning to add any additional effects and such, just select one item, I've set the end of the range to the same as the beginning. Structure of the vertical PathView. The red line marks the path, with red dots at positions 0/4 (top), 1/4, 2/4, 3/4 and 4/4 (bottom). The centers of the delegates are marked with blue. Horizontally The horizontal scrolling works similarly, with one important difference: there is a margin on the left of the currently selected item, where the previous one is halfway in the screen. We'll have to shift the whole path horizontally, and add 1 to the maximum number of visible items, and another one to account for scrolling, just like at the vertical axis. I've set the left margin previously to 100 px and the width of a game box to be 240x135. In addition, there's a 10px spacing between the elements, giving the full width of a box to 250. The center of the current-item would be at 100 + 250/2 = 225 on the path, but to make it align with the collection label, I'll shift it 5px (half of the spacing) to the left, making the X center to be 220px. Then counting backwards, the previous-item will be at 220 - 250, and the one before that (the leftmost postion, where the new elements will appear when scrolling) at 220 - 250 * 2. All right, let's change the horizontal ListView into a PathView: Before : ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate spacing: vpx ( 10 ) snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange preferredHighlightBegin: vpx ( 100 ) preferredHighlightEnd: preferredHighlightBegin + vpx ( 240 ) } After : PathView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom // removed orientation // removed spacing model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate // changed ListView to PathView snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange // brand new: path definitions pathItemCount: 2 + Math . ceil ( width / vpx ( 250 )) // note the 2 ! path: Path { startX: vpx ( 220 ) - vpx ( 250 ) * 2 startY: vpx ( 135 ) * 0.5 PathLine { x: gameAxis . path . startX + gameAxis . pathItemCount * vpx ( 250 ) y: gameAxis . path . startY } } // changed highlight range preferredHighlightBegin: 2 / pathItemCount preferredHighlightEnd: preferredHighlightBegin } And now both the horizontal and vertical axis loops as intended! Tip Typing out fixed values in pixels every time can be tedious and error prone. I'd recommend defining them as properties at the top of the object they're used in (eg. property real boxHeight: vpx(135) ). The rest of the theme The upper half of the screen contains the metadata and preview image of the currently selected game. The components here will consist of simple elements, like Image and Text, which will make adding them way easier. You can place all these elements directly under the main FocusScope , or you could create a containing Item if you wish. I'll do the former to keep the guide shorter. As for accessing the actual game data, we can use the properties of api.currentGame for metadata information, and api.currentGame.assets for the assets. You can find all the available fields listed in the API reference . Title A simple Text item in the upper left corner, with the left margin set to the same 100px we used at the game rows, and some additional margin at the top. Text { id: title text: api . currentGame . title color: white font.pixelSize: vpx ( 32 ) font.family: globalFonts . sans font.bold: true anchors.top: parent . top anchors.topMargin: vpx ( 42 ) anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } Rating The rating will be displayed as a five-star bar, with some percentage of it colored according to the actual rating. This can be done with two simple, overlapping QML Images: draw five empty stars first, then over them, draw filled ones according to the rating. Kind of like a progress bar, except we're using stars for filling. But first of all, I actuatlly draw two images for the stars, an empty one and a filled. Both have square size and transparent background. I create a new directory (eg. assets ) in my theme folder and put them there. star_empty.svg star_filled.svg Tip I've used Inkscape for drawing the vector art; it has a built-in tool for drawing stars and other polygons. Then I create the following Item. As the star image is a square, I make its width 5 times the height to hold the five stars horizontally. I make the empty-star Image fill this whole item, and set fillMode: Image.TileHorizontally to make the star repeat horizontally. For the filled-star image, I place it over the other one, and modify its width by the rating, which is provided as a number between 0.0 and 1.0 (0% and 100%). Item { id: rating // set the item s dimensions height: vpx ( 16 ) width: height * 5 // put it under the title anchors.top: title . bottom anchors.left: title . left // the empty stars Image { anchors.fill: parent source: assets/star_empty.svg sourceSize { width: parent . height ; height: parent . height } // the most important bits! fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } // the filled stars Image { anchors.top: parent . top anchors.left: parent . left width: parent . width * api . currentGame . rating // !!! height: parent . height source: assets/star_filled.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Note Without horizontalAlignment the stars might not line up perfectly (the repeat will start from the center). When a game has no rating defined, game.rating is 0.0 . Showing five empty stars for an otherwise good game might be a bit misleading, so I'll make the rating bar only appear when the rating is over 0%: Item { id: rating visible: api . currentGame . rating 0.0 // ... } Release year Yet another simple Text element: Text { id: year // if not defined, the release year is 0 visible: game . year 0 text: game . year color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans anchors.left: rating . right anchors.top: rating . top } Row Currently the year element is manually anchored right next to the rating. Doing this for each item every time is quite annoying, let's just put them in a Row : Row { id: detailsRow // anchor the whole row anchors.top: title . bottom anchors.topMargin: vpx ( 5 ) anchors.left: title . left spacing: vpx ( 10 ) Item { id: rating // remove anchor items! // anchors.top: title.bottom // anchors.left: title.left // ... } Text { id: year // remove anchor items! // anchors.left: rating.right // anchors.top: rating.top // ... } } Player count This one will be a rounded rectangle with smiley faces in it indicating the number of players. The player count defaults to one; similarly to the rating, I'll show the component only if the player count is more than one. First I create the smiley face image (based on the Unicode \"filled smiling face\" symbol ( U+263B ). Again, it's square sized with a transparent background. Then create a background rounded Rectangle and the smiles Image in it, putting the whole thing in the Row created in the previous step: Rectangle { id: multiplayer // the Rectangle s size depends on the Image, // with some additional padding width: smileys . width + vpx ( 8 ) height: smileys . height + vpx ( 5 ) color: #555 radius: vpx ( 3 ) visible: api . currentGame . players 1 Image { id: smileys // 13px looked good for me width: vpx ( 13 ) * api . currentGame . players height: vpx ( 13 ) anchors.centerIn: parent source: assets/smiley.svg sourceSize { width: smileys . height ; height: smileys . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Developer Yet another simple Text in the Row: Text { id: developer text: api . currentGame . developer color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } Tip A game may have multiple developers: if you just want to show them as a Text, you can use Game .developer , a string that simply lists them all. There's also Game .developerList , a JavaScript Array , if you wish to use them individually. Description A bigger text with set boundaries for alignment. If there is a short summary , I'll use that, otherwise the beginning of the full description. Text { id: description text: api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans // allow word wrapping, justify horizontally wrapMode: Text . WordWrap horizontalAlignment: Text . AlignJustify // if the text is too long, end it with an ellipsis (...) elide: Text . ElideRight anchors { left: detailsRow . left right: parent . horizontalCenter top: detailsRow . bottom ; topMargin: vpx ( 20 ) bottom: parent . verticalCenter ; bottomMargin: vpx ( 32 ) } } Screenshot This should be below everything else on the screen -- in fact, if you look at the image at the beginning of this guide, it's actually going into the bottom-half region of the screen, reaching the row of images. As it's under everything else, I'll put its implementation at the top of the theme file, even before the collection PathView. I'll anchor the top and left edges of the image to the top right corner of the screen. To make it go slightly into the bottom half, I'll anchor the bottom edge to the vertical center of the screen, then add a small amount of negative margin to the bottom (a positive margin reduces the size of the element, while a negative one increases it). Image { id: screenshot asynchronous: true fillMode: Image . PreserveAspectFit // set the first screenshot as source, or nothing source: api . currentGame . assets . screenshots [ 0 ] || sourceSize { width: 512 ; height: 512 } anchors.top: parent . top anchors.right: parent . right anchors.bottom: parent . verticalCenter anchors.bottomMargin: vpx ( - 45 ) // the height of the collection label } Note Using negative margins kind of feels like a hack though, so depending on the situation you might prefer to use simple width/height properties. Help The screenshots are stored under assets.screenshots , which is a regular JavaScript Array . If it's empty, screenshots[0] will be undefined , and setting an undefined value as the source of an Image will produce a warning in the log. Setting it to an empty string, however, will not, so appending || as a fallback will silence the warning. An alternative solution could be is to use screenshots as a model in eg. a ListView, and the Image as delegate. You could then further extend it to periodically change the current visible screenshot. Tip You can also use the z property of the components to set their relative \"height\". Gradients There are two linear gradients (\"fade-ins\"), one from the left and one from the bottom of the image. Such effect can be added just like regular components, can be positioned, sized, animated, etc. But first of all, to use gradients you'll need the QtGraphicalEffects QML module: import QtQuick 2.0 import QtGraphicalEffects 1.0 FocusScope { // ... } Then, create the horizontal linear gradient inside our Image component: Image { id: screenshot // ... LinearGradient { width: parent . width * 0.25 height: parent . height anchors.left: parent . left // since it goes straight horizontally from the left, // the Y of the point doesn t really matter start: Qt . point ( 0 , 0 ) end: Qt . point ( width , 0 ) // at the left side (0%), it starts with a fully visible black // at the right side (100%), it blends into transparency gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } } And another for the bottom: LinearGradient { width: parent . width height: vpx ( 50 ) anchors.bottom: parent . bottom // goes straight up, so the X of the point doesn t really matter start: Qt . point ( 0 , height ) end: Qt . point ( 0 , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } And we're done! Selection marker Perhaps not easy to notice on the example images, but actually there's a white rectangular border around the current item's place on the topmost horizontal axis. It's position is fixed and does not move even during scrolling. I'll create an empty, border-only Rectangle for it. Since it's over everything else in the theme, I'll put it to the bottom of the whole file, after the gameAxisDelegate 's definition. Rectangle { id: selectionMarker width: vpx ( 240 ) height: vpx ( 135 ) color: transparent border { width: 3 ; color: white } anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) anchors.top: parent . verticalCenter anchors.topMargin: vpx ( 45 ) } Opacity The currently active horizontal row is fully visible, while the rest are a bit darker. I'll set the opacity of the non-active rows to 60%. In addition, I'll add a light animation, so instead of a sudden change in the visibility, the rows gradually raise their opacity during scrolling. Simply add these two lines to the collectionAxisDelegate : Component { id: collectionAxisDelegate Item { // JS functions // width, height opacity: PathView . isCurrentItem ? 1.0 : 0.6 Behavior on opacity { NumberAnimation { duration: 150 } } // ... } } Done! With all these components added, it seems we're actually done! Here's the end result: And the full code: The code so far #3 import QtQuick 2.0 import QtGraphicalEffects 1.0 FocusScope { Image { id: screenshot asynchronous: true fillMode: Image . PreserveAspectFit source: api . currentGame . assets . screenshots [ 0 ] || sourceSize { width: 512 ; height: 512 } anchors.top: parent . top anchors.right: parent . right anchors.bottom: parent . verticalCenter anchors.bottomMargin: vpx ( - 45 ) LinearGradient { width: parent . width * 0.25 height: parent . height anchors.left: parent . left start: Qt . point ( 0 , 0 ) end: Qt . point ( width , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } LinearGradient { width: parent . width height: vpx ( 50 ) anchors.bottom: parent . bottom start: Qt . point ( 0 , height ) end: Qt . point ( 0 , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } } Text { id: title text: api . currentGame . title color: white font.pixelSize: vpx ( 32 ) font.family: globalFonts . sans font.bold: true anchors.top: parent . top anchors.topMargin: vpx ( 42 ) anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } Row { id: detailsRow anchors.top: title . bottom anchors.topMargin: vpx ( 5 ) anchors.left: title . left spacing: vpx ( 10 ) Item { id: rating visible: api . currentGame . rating 0.0 height: vpx ( 16 ) width: height * 5 Image { anchors.fill: parent source: assets/star_empty.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } Image { anchors.top: parent . top anchors.left: parent . left width: parent . width * api . currentGame . rating height: parent . height source: assets/star_filled.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Text { id: year visible: api . currentGame . year 0 text: api . currentGame . year color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } Rectangle { id: multiplayer width: smileys . width + vpx ( 8 ) height: smileys . height + vpx ( 5 ) color: #555 radius: vpx ( 3 ) visible: api . currentGame . players 1 Image { id: smileys width: vpx ( 13 ) * api . currentGame . players height: vpx ( 13 ) anchors.centerIn: parent source: assets/smiley.svg sourceSize { width: smileys . height ; height: smileys . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Text { id: developer text: api . currentGame . developer color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Text { id: description text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignJustify elide: Text . ElideRight anchors { left: detailsRow . left right: parent . horizontalCenter top: detailsRow . bottom ; topMargin: vpx ( 20 ) bottom: parent . verticalCenter ; bottomMargin: vpx ( 32 ) } } PathView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange clip: true pathItemCount: 1 + Math . ceil ( height / vpx ( 180 )) path: Path { startX: collectionAxis . width * 0.5 startY: vpx ( 180 ) * - 0.5 PathLine { x: collectionAxis . path . startX y: collectionAxis . path . startY + collectionAxis . pathItemCount * vpx ( 180 ) } } preferredHighlightBegin: 1 / pathItemCount preferredHighlightEnd: preferredHighlightBegin focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Component { id: collectionAxisDelegate Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } width: PathView . view . width height: vpx ( 180 ) opacity: PathView . isCurrentItem ? 1.0 : 0.6 Behavior on opacity { NumberAnimation { duration: 150 } } Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans font.bold: true height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } PathView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange pathItemCount: 2 + Math . ceil ( width / vpx ( 250 )) path: Path { startX: vpx ( 220 ) - vpx ( 250 ) * 2 startY: vpx ( 135 ) * 0.5 PathLine { x: gameAxis . path . startX + gameAxis . pathItemCount * vpx ( 250 ) y: gameAxis . path . startY } } preferredHighlightBegin: 2 / pathItemCount preferredHighlightEnd: preferredHighlightBegin } } } Component { id: gameAxisDelegate Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 visible: image . status !== Image . Ready Text { text: modelData . title anchors.fill: parent anchors.margins: vpx ( 12 ) horizontalAlignment: Text . AlignHCenter verticalAlignment: Text . AlignVCenter wrapMode: Text . Wrap color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Image { id: image anchors.fill: parent visible: source fillMode: Image . PreserveAspectCrop asynchronous: true source: assets . banner || assets . steam || assets . boxFront sourceSize { width: 256 ; height: 256 } } } } Rectangle { id: selectionMarker width: vpx ( 240 ) height: vpx ( 135 ) color: transparent border { width: 3 ; color: white } anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) anchors.top: parent . verticalCenter anchors.topMargin: vpx ( 45 ) } } It's a bit long, but then again this theme had some complex layouting going on. A possible separation to multiple QML files would look like this: Screenshot.qml import QtQuick 2.0 import QtGraphicalEffects 1.0 Image { asynchronous: true fillMode: Image . PreserveAspectFit source: api . currentGame . assets . screenshots [ 0 ] || sourceSize { width: 512 ; height: 512 } LinearGradient { width: parent . width * 0.25 height: parent . height anchors.left: parent . left start: Qt . point ( 0 , 0 ) end: Qt . point ( width , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } LinearGradient { width: parent . width height: vpx ( 50 ) anchors.bottom: parent . bottom start: Qt . point ( 0 , height ) end: Qt . point ( 0 , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } } Title.qml import QtQuick 2.0 Text { text: api . currentGame . title color: white font.pixelSize: vpx ( 32 ) font.family: globalFonts . sans font.bold: true } Rating.qml import QtQuick 2.0 Item { visible: api . currentGame . rating 0.0 height: vpx ( 16 ) width: height * 5 Image { anchors.fill: parent source: assets/star_empty.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } Image { anchors.top: parent . top anchors.left: parent . left width: parent . width * api . currentGame . rating height: parent . height source: assets/star_filled.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } ReleaseYear.qml import QtQuick 2.0 Text { visible: api . currentGame . year 0 text: api . currentGame . year color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } MultiplayerIcon.qml import QtQuick 2.0 Rectangle { width: smileys . width + vpx ( 8 ) height: smileys . height + vpx ( 5 ) color: #555 radius: vpx ( 3 ) visible: api . currentGame . players 1 Image { id: smileys width: vpx ( 13 ) * api . currentGame . players height: vpx ( 13 ) anchors.centerIn: parent source: assets/smiley.svg sourceSize { width: smileys . height ; height: smileys . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Description.qml import QtQuick 2.0 Text { text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignJustify elide: Text . ElideRight } CollectionAxis.qml import QtQuick 2.0 PathView { id: collectionAxis model: api . collectionList . model currentIndex: api . collectionList . index delegate: CollectionAxisDelegate { } snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange clip: true pathItemCount: 1 + Math . ceil ( height / vpx ( 180 )) path: Path { startX: collectionAxis . width * 0.5 startY: vpx ( 180 ) * - 0.5 PathLine { x: collectionAxis . path . startX y: collectionAxis . path . startY + collectionAxis . pathItemCount * vpx ( 180 ) } } preferredHighlightBegin: 1 / pathItemCount preferredHighlightEnd: preferredHighlightBegin focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } CollectionAxisDelegate.qml import QtQuick 2.0 Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } width: PathView . view . width height: vpx ( 180 ) opacity: PathView . isCurrentItem ? 1.0 : 0.6 Behavior on opacity { NumberAnimation { duration: 150 } } Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans font.bold: true height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } PathView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: GameAxisDelegate { } snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange pathItemCount: 2 + Math . ceil ( width / vpx ( 250 )) path: Path { startX: vpx ( 220 ) - vpx ( 250 ) * 2 startY: vpx ( 135 ) * 0.5 PathLine { x: gameAxis . path . startX + gameAxis . pathItemCount * vpx ( 250 ) y: gameAxis . path . startY } } preferredHighlightBegin: 2 / pathItemCount preferredHighlightEnd: preferredHighlightBegin } } GameAxisDelegate.qml import QtQuick 2.0 Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 visible: image . status !== Image . Ready Text { text: modelData . title anchors.fill: parent anchors.margins: vpx ( 12 ) horizontalAlignment: Text . AlignHCenter verticalAlignment: Text . AlignVCenter wrapMode: Text . Wrap color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Image { id: image anchors.fill: parent visible: source fillMode: Image . PreserveAspectCrop asynchronous: true source: assets . banner || assets . steam || assets . boxFront sourceSize { width: 256 ; height: 256 } } } SelectionMarker.qml import QtQuick 2.0 Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: transparent border { width: 3 ; color: white } } theme.qml import QtQuick 2.0 FocusScope { Screenshot { id: screenshot anchors.top: parent . top anchors.right: parent . right anchors.bottom: parent . verticalCenter anchors.bottomMargin: vpx ( - 45 ) } Title { id: title anchors.top: parent . top anchors.topMargin: vpx ( 42 ) anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } Row { id: detailsRow anchors.top: title . bottom anchors.topMargin: vpx ( 5 ) anchors.left: title . left spacing: vpx ( 10 ) Rating { } ReleaseYear { } MultiplayerIcon { } Developer { } } Description { id: description anchors { left: detailsRow . left right: parent . horizontalCenter top: detailsRow . bottom ; topMargin: vpx ( 20 ) bottom: parent . verticalCenter ; bottomMargin: vpx ( 32 ) } } CollectionAxis { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom } SelectionMarker { anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) anchors.top: parent . verticalCenter anchors.topMargin: vpx ( 45 ) } } theme.cfg name : Flixnet tutorial author : M\u00e1ty\u00e1s Mustoha","title":"Example -- Flixnet theme"},{"location":"themes/example-flixnet/#step-by-step-flixnet-theme","text":"In this tutorial, we'll implement the theme above from scratch, inspired by the UI of a certain video streaming company. While the guide is intended to be beginner-friendly, this is a somewhat complex project, so you might want to be familiar with the QML basics and dynamic layout elements (see the QML tutorials ). If we simplify it a bit, here's how its structure and navigation looks like: As you can see, there are two main axes of motion: a horizontal game axis for each collection's games a vertical collection axis for selecting a collection Each row can be individually scrolled, and the currently selected game is the topmost row's first (fully visible) item. Furthermore, the rows themselves can also be scrolled vertically. This kind of layout makes the theme a bit complex, but other than these axes the rest of the theme seems to be simple enough. Let's get started!","title":"Step-by-step: Flixnet theme"},{"location":"themes/example-flixnet/#initial-files","text":"I'm on Linux, so my theme directory is at ~/.config/pegasus-frontend/themes . I'm creating a new directory called flixnet-tutorial , and in it my theme.cfg , like this: name : Flixnet tutorial author : M\u00e1ty\u00e1s Mustoha and the basic theme.qml : import QtQuick 2.0 FocusScope { } Now I open Pegasus and select this theme on the Settings screen. I'll keep Pegasus open during the development, and refresh the theme with the F5 key. I also open the main log file ~/.config/pegasus-frontend/lastrun.log which will tell me if I've made any errors in the QML file. Tip You can use whatever text editor you like. Qt Creator is cross platform, has good auto-complete and syntax highlight features. For a more lightweight editor, Sublime Text with the QML package, Atom or Notepad++ could be used, among others. Note You might see .qmlc files popping up in your theme's directory. These are cache files, generated for faster loading. When copying the theme to a different machine, you don't have to bring them, they'll automatically get generated the next time you launch Pegasus.","title":"Initial files"},{"location":"themes/example-flixnet/#initial-layout","text":"Let's start with the hard part, the layout on the bottom half. This is a vertically scrollable list of horizontally scrollable lists, each containing boxes for the games. Because collections are what contain the games, I'll first start making the vertical axis that selects the collection, and then add the horizontal game selection after that. I'll write a rough initial structure first, as once you have the basic layout done, you can tweak the elements as much as you want.","title":"Initial layout"},{"location":"themes/example-flixnet/#some-planning","text":"The game selection layout will take the whole lower half of the screen. On a standard 16:9 screen I want to show 2 rows of games to appear, and incrementally more on screens with smaller aspect ratios. Using Pegasus' virtual pixel values, I can design the theme for a screen with at least 720px height, and the values will scale appropriately for other resolutions. Based on that, if the height of the list is half the screen's height, I'll have 360px at least if I want to show two rows, one row's full height in the list will be 180px I'll use 18px font size for the collection's name to have some space around the text, I'll use 250% line height; that's 45px out of the 180px so far I'm left with 135px height to use for the game boxes the game boxes will have a 16:9 aspect ratio, so their width will be 240px Ok, let's start coding!","title":"Some planning"},{"location":"themes/example-flixnet/#vertical-axis","text":"A simple type for laying out a variable amount of items with one of them being selected is ListView . I set it up so it takes the whole lower half of the screen: import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom } } One element of this collection axis will have 180px height and the width is the whole width of the screen. I'll create a placeholder for now and add a fake model (a series of numbers) for testing (so you can see that they indeed come in order, and the ListView has the correct amount of items): import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: 10 // just some random number delegate: Rectangle { width: ListView . view . width height: vpx ( 180 ) color: blue } } } If you now refresh Pegasus, you'll see the lower half of the screen turned blue. Yay! vpx The function vpx is what you can use for virtual pixel values. It scales up or down the pixel value you put into it depending on the actual screen resolution. delegate The visual element of a list is called delegate . For every data item of the model (in this case, for every number between 0 and 9), a delegate will be created. The code looks good so far, I'll just make a small change: the delegate will likely get more complex later, so to make it easier to read, I'll move it out into a separate Component : import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: 10 delegate: collectionAxisDelegate } Component { id: collectionAxisDelegate Rectangle { width: ListView . view . width height: vpx ( 180 ) color: blue } } } Tip Component is a special element that defines a QML document. Actually, you could even move the Rectangle to a new file (eg. CollectionAxisDelegate.qml ) and use the file's name to set the delegate (eg. delegate: CollectionAxisDelegate { } ).","title":"Vertical axis"},{"location":"themes/example-flixnet/#horizontal-axis","text":"The rows of the collection axis will consist of two things: a Text label that shows the collection's name and a ListView that shows its games. Because a Component can have only one child, I'll turn the Rectangle into an Item (an otherwise invisible container), and put a Text and a ListView into it. Note Just as individual QML files can have only one root element, Component can have only one child. First I'll add the collection label: import QtQuick 2.0 FocusScope { ListView { id: collectionAxis // ... } Component { id: collectionAxisDelegate Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label // `modelData` is the item in the list s model // for which this delegate is created for; // in this case a number between 0-9 text: modelData // white, bold 18px font, using Pegasus default font family color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans font.bold: true // make the line height 45px high // and center the text vertically in it height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter } } } } If you refresh the theme in Pegasus, you'll now see the numbers \"0\" and \"1\" at where we'd expect the labels. I'll now add the horizontal ListView : Component { id: collectionAxisDelegate Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label // ... } ListView { id: gameAxis // span from left to right, from the label s bottom to the row s bottom anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom // this one goes horizontal! orientation: ListView . Horizontal } } } We'll need a model and a delegate item to actually see something. Let's create some dummy items: import QtQuick 2.0 FocusScope { // ... Component { id: collectionAxisDelegate Item { // ... ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: 20 delegate: gameAxisDelegate spacing: vpx ( 10 ) // some spacing to make it look fancy } } } // this is one item of the horizontal axis, ie. a game box Component { id: gameAxisDelegate Rectangle { // as we calculated previously width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { // will become a number between 0-19 text: modelData } } } } And here's how it should look so far: Not the most beautiful yet, however with this we're done with the basics of the main layout. From now on we'll just have tweak these lists and delegates, then add some simple components for the metadata.","title":"Horizontal axis"},{"location":"themes/example-flixnet/#the-code-so-far-1","text":"Here's the whole code so far (without comments to save space): The code so far #1 import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: 10 delegate: collectionAxisDelegate } Component { id: collectionAxisDelegate Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label text: modelData color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter } ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: 20 delegate: gameAxisDelegate spacing: vpx ( 10 ) } } } Component { id: gameAxisDelegate Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { text: modelData } } } }","title":"The code so far #1"},{"location":"themes/example-flixnet/#navigation","text":"You might have noticed that the components react already to mouse drag or scroll, but keyboard and gamepad input doesn't work yet. Let's fix this.","title":"Navigation"},{"location":"themes/example-flixnet/#vertical-scroll","text":"Simply add focus: true to the collection axis: ListView { id: collectionAxis // ... focus: true } You can now scroll the bars with Up and Down , but... it's kind of weird right now. It'd be better for the items to \"snap\" to their place, to scroll to the next item when we press a button. This can be fixed with the snapMode and highlightRangeMode properties: setting snapMode keeps the elements organized when scrolling the list as a whole, while highlightRangeMode will make sure the selection follows the scrolling (that is, when you press Up or Down , you actually select the next or previous element, not just view a different part of the list). ListView { id: collectionAxis // ... snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange focus: true } There, much better now. Tip Setting up the keyboard input also makes gamepads work. Check the Controls page to see how are they related. By default, every delegate that is at least partially in the ListView's area is fully drawn. To make sure only the rows in the lower half of the screen are visible, I set clip on the ListView : ListView { id: collectionAxis // ... snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange clip: true focus: true }","title":"Vertical scroll"},{"location":"themes/example-flixnet/#horizontal-scroll","text":"We have a somewhat complex layout -- scrollable items inside a scrollable item; we can't just set focus: true here, since that'd mean we set it for each row, and end up with scrolling one we don't want. Hovewer, every ListView has select-next and select-previous function we can use ( incrementCurrentIndex() , decrementCurrentIndex() ), and the currently selected item can be accessed through currentItem . In this case, the currentItem of collectionAxis will be the Item element inside collectionAxisDelegate : Component { id: collectionAxisDelegate // this one! Item { width: ListView . view . width height: vpx ( 180 ) Text { id: label // ... } ListView { id: gameAxis // ... } } } But how can we access the ListView, gameAxis of the Item? Turns out we can't just use its id , as it's not accessible by external element (we'll get an error about gameAxis being undefined). Function definitions and property members, however, can be accessed. For now, I'll simply create an alias property for the horizontal axis: Component { id: collectionAxisDelegate Item { property alias axis: gameAxis width: ListView . view . width height: vpx ( 180 ) Text { id: label // ... } ListView { id: gameAxis // ... } } } We can now access the game axis of the current collection as currentItem.axis (see below). Note Yes, you can also write it like property alias gameAxis: gameAxis , I simply preferred the different name in this case. Combining the ListView functions, currentItem and manual keyboard handling ( Keys ), we can now make the horizontal scrolling work with: ListView { id: collectionAxis // ... focus: true Keys.onLeftPressed: currentItem . axis . decrementCurrentIndex () Keys.onRightPressed: currentItem . axis . incrementCurrentIndex () } ...which, similarly to the vertical axis, initially scrolls in a not so nice way. Fix it like previously, but in the delegate: ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: 100 delegate: gameAxisDelegate spacing: vpx ( 10 ) snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange } And now both directions should scroll finely! Tip To see that the current item indeed changes, you could set the color of the gameAxisDelegate 's Rectangle to: color: ListView . isCurrentItem ? orange : green","title":"Horizontal scroll"},{"location":"themes/example-flixnet/#left-margin","text":"There's a small margin on the left that shows the game before the currently selected one. We don't want to reduce the size of the horizontal ListView s (they should fill the whole width of the screen), we just want to move the currently selected item a little bit right. For this, we can use the preferredHighlightBegin / End members of the ListView s: they can be used to define a fixed position range (in pixels) where the currently selected element should reside. I'll set a 100px offset like this: ListView { id: gameAxis // ... preferredHighlightBegin: vpx ( 100 ) preferredHighlightEnd: preferredHighlightBegin + vpx ( 240 ) // the width of one game box } Help preferredHighlightBegin and preferredHighlightEnd almost always come in pair, and End must be greater or equal than Begin to have their effect applied. We also need to move the collection label too. As it's just a regular Text element, I'll simply set its left anchor and a margin on it: Component { id: collectionAxisDelegate Item { // ... Text { id: label // ... anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } ListView { id: gameAxis // ... } } } Note The anchor margin is only applied if the anchor itself is defined. Tip You can also use the Text item's leftPadding property. This feature was added in Qt 5.6 (as mentioned in the official documentation ), so you'll need to change the import command on the top of the QML file to import QtQuick 2.6 or higher (Pegasus comes with Qt 5.9 at the moment).","title":"Left margin"},{"location":"themes/example-flixnet/#using-api-data","text":"Finally, the time has come to replace the placeholder elements with actual content. Let's start by using the real collection data. According to the API reference , collections can be accessed and selected through api.collectionList : we can use api.collectionList.model as the model of a ListView (or any other View) and index as the currentIndex of it. We can then call increaseIndex() and decreaseIndex() to move to the next and previous items (or by setting the index manually).","title":"Using API data"},{"location":"themes/example-flixnet/#vertical-axis_1","text":"First, find the ListView for the collection axis and set its model property. Then add the currentIndex line to bind it to the index from the API. Finally, call increaseIndex() and decreaseIndex() when Up and Down is pressed: ListView { id: collectionAxis // ... model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate // ... focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . axis . decrementCurrentIndex () Keys.onRightPressed: currentItem . axis . incrementCurrentIndex () } Warning Incrementing/decrementing the currentIndex property of a ListView (eg. by navigation) has no effect on the bound value (in this case api.collectionList.index ); this is why I call incrementIndex() / decrementIndex() manually on Up and Down . We'll also modify the Left / Right keys very soon. Tip Instead of using Keys and increment/decrement, you can also set api.collectionList.index manually, eg. onCurrentIndexChanged: api . collectionList . index = currentIndex Help incrementIndex() and decrementIndex() wraps around (incrementing the index at the last item will make it jump to the first one). If you don't want them to wrap, you can use incrementIndexNoWrap() and decrementIndexNoWrap() instead. Previously the model was set to 10 , and so the modelData available in the delegates was a number between 0 and 9. With model set to api.collectionList.model , the modelData will be a Collection object. A Collection always has a name , so let's show that: Component { id: collectionAxisDelegate Item { // ... Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans // ... } ListView { id: gameAxis // ... } } } Tip If the name of the modelData property you use (in this case name ) don't collide with other properties of the object, it's not required to type out modelData : you can simply write text: name . After a refresh, you should see the names of collections appearing in Pegasus.","title":"Vertical axis"},{"location":"themes/example-flixnet/#horizontal-axis_1","text":"Now let's show the game titles in the horizontal rectangles. Every Collection has a gameList member we can use to access the list of games associated with the collection. Similarly to collectionList , gameList also has model and index properties, so let's use them in the horizontal axis ( collectionAxisDelegate ): Component { id: collectionAxisDelegate Item { // ... Text { id: label // ... } ListView { id: gameAxis // ... model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate spacing: vpx ( 10 ) // ... } } } Just like with the vertical axis, I'll use incrementIndex() and decrementIndex() again. Currently we access the horizontal ListView of the collection delegate via an alias property, and call the ListView's incrementCurrentIndex() and decrementCurrentIndex() methods by Keys.onLeftPressed and Keys.onRightPressed of the collection axis. Instead, we should call the index changing functions of the API, of the Collection belonging to a delegate (ie. modelData ). As usual, there are more than one way to do it, I'll show how you can use JavaScript functions this time. First, find the property alias axis: gameAxis line Component { id: collectionAxisDelegate Item { property alias axis: gameAxis // this one // ... Text { ... } ListView { ... } } } then delete and replace it with the selectNext() and selectPrev() functions, with the increment/decrement methods of the API in their body: Component { id: collectionAxisDelegate Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } // ... Text { ... } ListView { ... } } } Then you can call the new functions in the collectionAxis like this: ListView { id: collectionAxis // ... model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate // ... focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () } And now the Views scroll properly, with the real data!","title":"Horizontal axis"},{"location":"themes/example-flixnet/#game-items","text":"With the previous changes, gameAxisDelegate is now a visual representation for a Game element. A Game always has a title , so we can simply set it as the text: Component { id: gameAxisDelegate Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { text: modelData . title } } } Help The model of the vertical ListView was a list of Collection s, so the modelData received by a delegate of that ListView (one whole horizontal row) is one Collection object. The model of these horizontal ListViews is a list of Game s, so a delegate of the horizontal ListViews will see a Game in its modelData . And now the game names also show up in Pegasus:","title":"Game items"},{"location":"themes/example-flixnet/#launching-games","text":"Now that the game selection items are in sync with the API, we can actually launch games! To start the currently selected game, simply call api.currentGame.launch() when Enter is pressed: ListView { id: collectionAxis // ... focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Help Careful not to confuse the onReturnPressed and onEnterPressed calls: technically Return is the key next to the letters, while Enter is the one on the numeric keypad. Note onReturnPressed is also triggered by pressing / on the gamepad. And with this, technically our theme is fully functional! Next step, let's make it pretty.","title":"Launching games"},{"location":"themes/example-flixnet/#the-code-so-far-2","text":"The code so far #2 import QtQuick 2.0 FocusScope { ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange clip: true focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Component { id: collectionAxisDelegate Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } width: ListView . view . width height: vpx ( 180 ) Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate spacing: vpx ( 10 ) snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange preferredHighlightBegin: vpx ( 100 ) preferredHighlightEnd: preferredHighlightBegin + vpx ( 240 ) } } } Component { id: gameAxisDelegate Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: green Text { text: modelData . title } } } }","title":"The code so far #2"},{"location":"themes/example-flixnet/#fancy-game-boxes","text":"I'll now replace the green game boxes with something better to look at. There are two main cases we have to support: if there is an available image for a game, the box should show that if there is none, or the image has not loaded yet, the box should show a gray rectangle, with the game's title in the center So gameAxisDelegate is our game box that right now contains a green rectangle. I'll turn that into an Item, and, for the two cases above, I'll add an initial gray Rectangle and Image: Component { id: gameAxisDelegate Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 } Image { id: image anchors.fill: parent } } } So which image asset should we use? A game box is a rectangle with 16:9 aspect ratio, so the banner would be perfect for this. However, since every asset is potentially missing, we should consider showing other images and provide multiple fallbacks. If we don't have a banner , the next similarly sized one is the steam (\"grid icon\") asset. Because it's wider than 16:9, we'll need to crop it if we don't want black bars or squashed/scretched images (though you might prefer that). If neither image is available, I'll use boxFront as it tends to be commonly available. Let's extend the Image object created previously: Image { id: image anchors.fill: parent visible: source // fill the whole area, cropping what lies outside fillMode: Image . PreserveAspectCrop asynchronous: true source: assets . banner || assets . steam || assets . boxFront sourceSize { width: 256 ; height: 256 } } I've also made some optimizations here: I've set asynchronous: true : Loading image files takes some time depending on the device Pegasus runs on. If this property is set to false (default), the program will not react to input until the image is loaded (or noticed that it failed to load). If it's false, the image is loaded \"in the background\", and input is not blocked; hovewer depending on your theme, you might want to show something in its place for the users during this time (eg. a loading spinner or progress bar). I've set sourceSize : This sets the maximum size the image should occupy in the memory. The official documentation describes this in detail. I've set visible: source , that is, if the source is empty (neither banner , steam or boxFront is available), then ignore this whole object: no input will be ever handled here and there's nothing to see either. With these changes, here's how it looks: Starting to take shape, isn't it? Let's finish the text-only fallback too: Component { id: gameAxisDelegate Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 visible: image . status !== Image . Ready Text { text: modelData . title // define the text area anchors.fill: parent anchors.margins: vpx ( 12 ) // align to the center horizontalAlignment: Text . AlignHCenter verticalAlignment: Text . AlignVCenter wrapMode: Text . Wrap // set the font color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Image { id: image // ... } } } And we're done with the game boxes!","title":"Fancy game boxes"},{"location":"themes/example-flixnet/#looping-the-axes","text":"It'd be nice if all of the lists would loop around. You can do two kinds of loop: make the list finite and when the last item is reached, jump back to the first one (and also in reverse direction) make the list infinite and loop around (carousel style) The first one can be done either by simply setting keyNavigationWraps: true for a ListView (and other Views) or using the API's default index increase/decrease functions. In our case though, the carousel option would look the best. I won't lie, making a carousel-like looping list is annoying and overly complex for this use case; the situation might improve later by creating some easier-to-use custom types in Pegasus.","title":"Looping the axes"},{"location":"themes/example-flixnet/#vertically","text":"So the problem is, ListView can't do carousels: the only type that can is PathView. As such, we'll turn our ListViews into PathViews next. Again, let's start with the vertical axis; here's a before-after comparison, with some comments after the code: Before ListView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange clip: true focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } After PathView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate // changed ListView to PathView snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange clip: true // brand new: path definitions pathItemCount: 1 + Math . ceil ( height / vpx ( 180 )) path: Path { startX: collectionAxis . width * 0.5 startY: vpx ( 180 ) * - 0.5 PathLine { x: collectionAxis . path . startX y: collectionAxis . path . startY + collectionAxis . pathItemCount * vpx ( 180 ) } } preferredHighlightBegin: 1 / pathItemCount preferredHighlightEnd: preferredHighlightBegin focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Warning Don't forget to change ListView to PathView in the delegate ( collectionAxisDelegate 's width prop) too! Unlike ListView that goes to one direction only, PathView can be used to create arbitrary paths on which the items will travel (curves, circles, all kinds of shapes). Because of that, some properties have to be provided in percentage or need manual calculations. For PathViews, pathItemCount must be set (the default behaviour is to show all items). We should show as many rows as it fits into lower half or the screen (one row's height is 180px). The number of visible items thus will be [area height] / [row height], which I've rounded up using Math.ceil , a standard JavaScript function. However, when there's a scrolling going on, there'll be actually one more row visible on the screen: the topmost row will gradually go out on the top of the lower area, while a new line is on its way in to appear on the bottom (see the animation below). The path defines the trail the elements will follow by their center point . Because there'll be one item that slides out , and one that slides in , the path extends above and below the PathView's area. The starting point of the axis (the center point of the item that will slide out) is horizontally ( startX ) the center of the screen (as the rows fill the width), and vertically ( startY ) above the top edge of the PathView (which would be 0) by 50% of the row height (where values are in pixels). From the start point, a linear path is created with PathLine : I've set it so the end point is the same as the start except the Y coordinate, which is increased by the length ot the path, [number of max. visible items] * [item height]. The preferred highlight positions are in percentage for the PathView (as it can have any kind of shape, pixels don't always make sense). Again, the values define the range for the center point of the selected item. It defaults to 0 (start of the line), which in our case would be the center of the sliding out element, out of the visible area. I've set it to [1] / [item count], which will produce the center point of the second element on the path. Since I'm not planning to add any additional effects and such, just select one item, I've set the end of the range to the same as the beginning. Structure of the vertical PathView. The red line marks the path, with red dots at positions 0/4 (top), 1/4, 2/4, 3/4 and 4/4 (bottom). The centers of the delegates are marked with blue.","title":"Vertically"},{"location":"themes/example-flixnet/#horizontally","text":"The horizontal scrolling works similarly, with one important difference: there is a margin on the left of the currently selected item, where the previous one is halfway in the screen. We'll have to shift the whole path horizontally, and add 1 to the maximum number of visible items, and another one to account for scrolling, just like at the vertical axis. I've set the left margin previously to 100 px and the width of a game box to be 240x135. In addition, there's a 10px spacing between the elements, giving the full width of a box to 250. The center of the current-item would be at 100 + 250/2 = 225 on the path, but to make it align with the collection label, I'll shift it 5px (half of the spacing) to the left, making the X center to be 220px. Then counting backwards, the previous-item will be at 220 - 250, and the one before that (the leftmost postion, where the new elements will appear when scrolling) at 220 - 250 * 2. All right, let's change the horizontal ListView into a PathView: Before : ListView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom orientation: ListView . Horizontal model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate spacing: vpx ( 10 ) snapMode: ListView . SnapOneItem highlightRangeMode: ListView . StrictlyEnforceRange preferredHighlightBegin: vpx ( 100 ) preferredHighlightEnd: preferredHighlightBegin + vpx ( 240 ) } After : PathView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom // removed orientation // removed spacing model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate // changed ListView to PathView snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange // brand new: path definitions pathItemCount: 2 + Math . ceil ( width / vpx ( 250 )) // note the 2 ! path: Path { startX: vpx ( 220 ) - vpx ( 250 ) * 2 startY: vpx ( 135 ) * 0.5 PathLine { x: gameAxis . path . startX + gameAxis . pathItemCount * vpx ( 250 ) y: gameAxis . path . startY } } // changed highlight range preferredHighlightBegin: 2 / pathItemCount preferredHighlightEnd: preferredHighlightBegin } And now both the horizontal and vertical axis loops as intended! Tip Typing out fixed values in pixels every time can be tedious and error prone. I'd recommend defining them as properties at the top of the object they're used in (eg. property real boxHeight: vpx(135) ).","title":"Horizontally"},{"location":"themes/example-flixnet/#the-rest-of-the-theme","text":"The upper half of the screen contains the metadata and preview image of the currently selected game. The components here will consist of simple elements, like Image and Text, which will make adding them way easier. You can place all these elements directly under the main FocusScope , or you could create a containing Item if you wish. I'll do the former to keep the guide shorter. As for accessing the actual game data, we can use the properties of api.currentGame for metadata information, and api.currentGame.assets for the assets. You can find all the available fields listed in the API reference .","title":"The rest of the theme"},{"location":"themes/example-flixnet/#title","text":"A simple Text item in the upper left corner, with the left margin set to the same 100px we used at the game rows, and some additional margin at the top. Text { id: title text: api . currentGame . title color: white font.pixelSize: vpx ( 32 ) font.family: globalFonts . sans font.bold: true anchors.top: parent . top anchors.topMargin: vpx ( 42 ) anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) }","title":"Title"},{"location":"themes/example-flixnet/#rating","text":"The rating will be displayed as a five-star bar, with some percentage of it colored according to the actual rating. This can be done with two simple, overlapping QML Images: draw five empty stars first, then over them, draw filled ones according to the rating. Kind of like a progress bar, except we're using stars for filling. But first of all, I actuatlly draw two images for the stars, an empty one and a filled. Both have square size and transparent background. I create a new directory (eg. assets ) in my theme folder and put them there. star_empty.svg star_filled.svg Tip I've used Inkscape for drawing the vector art; it has a built-in tool for drawing stars and other polygons. Then I create the following Item. As the star image is a square, I make its width 5 times the height to hold the five stars horizontally. I make the empty-star Image fill this whole item, and set fillMode: Image.TileHorizontally to make the star repeat horizontally. For the filled-star image, I place it over the other one, and modify its width by the rating, which is provided as a number between 0.0 and 1.0 (0% and 100%). Item { id: rating // set the item s dimensions height: vpx ( 16 ) width: height * 5 // put it under the title anchors.top: title . bottom anchors.left: title . left // the empty stars Image { anchors.fill: parent source: assets/star_empty.svg sourceSize { width: parent . height ; height: parent . height } // the most important bits! fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } // the filled stars Image { anchors.top: parent . top anchors.left: parent . left width: parent . width * api . currentGame . rating // !!! height: parent . height source: assets/star_filled.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Note Without horizontalAlignment the stars might not line up perfectly (the repeat will start from the center). When a game has no rating defined, game.rating is 0.0 . Showing five empty stars for an otherwise good game might be a bit misleading, so I'll make the rating bar only appear when the rating is over 0%: Item { id: rating visible: api . currentGame . rating 0.0 // ... }","title":"Rating"},{"location":"themes/example-flixnet/#release-year","text":"Yet another simple Text element: Text { id: year // if not defined, the release year is 0 visible: game . year 0 text: game . year color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans anchors.left: rating . right anchors.top: rating . top }","title":"Release year"},{"location":"themes/example-flixnet/#row","text":"Currently the year element is manually anchored right next to the rating. Doing this for each item every time is quite annoying, let's just put them in a Row : Row { id: detailsRow // anchor the whole row anchors.top: title . bottom anchors.topMargin: vpx ( 5 ) anchors.left: title . left spacing: vpx ( 10 ) Item { id: rating // remove anchor items! // anchors.top: title.bottom // anchors.left: title.left // ... } Text { id: year // remove anchor items! // anchors.left: rating.right // anchors.top: rating.top // ... } }","title":"Row"},{"location":"themes/example-flixnet/#player-count","text":"This one will be a rounded rectangle with smiley faces in it indicating the number of players. The player count defaults to one; similarly to the rating, I'll show the component only if the player count is more than one. First I create the smiley face image (based on the Unicode \"filled smiling face\" symbol ( U+263B ). Again, it's square sized with a transparent background. Then create a background rounded Rectangle and the smiles Image in it, putting the whole thing in the Row created in the previous step: Rectangle { id: multiplayer // the Rectangle s size depends on the Image, // with some additional padding width: smileys . width + vpx ( 8 ) height: smileys . height + vpx ( 5 ) color: #555 radius: vpx ( 3 ) visible: api . currentGame . players 1 Image { id: smileys // 13px looked good for me width: vpx ( 13 ) * api . currentGame . players height: vpx ( 13 ) anchors.centerIn: parent source: assets/smiley.svg sourceSize { width: smileys . height ; height: smileys . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } }","title":"Player count"},{"location":"themes/example-flixnet/#developer","text":"Yet another simple Text in the Row: Text { id: developer text: api . currentGame . developer color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } Tip A game may have multiple developers: if you just want to show them as a Text, you can use Game .developer , a string that simply lists them all. There's also Game .developerList , a JavaScript Array , if you wish to use them individually.","title":"Developer"},{"location":"themes/example-flixnet/#description","text":"A bigger text with set boundaries for alignment. If there is a short summary , I'll use that, otherwise the beginning of the full description. Text { id: description text: api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans // allow word wrapping, justify horizontally wrapMode: Text . WordWrap horizontalAlignment: Text . AlignJustify // if the text is too long, end it with an ellipsis (...) elide: Text . ElideRight anchors { left: detailsRow . left right: parent . horizontalCenter top: detailsRow . bottom ; topMargin: vpx ( 20 ) bottom: parent . verticalCenter ; bottomMargin: vpx ( 32 ) } }","title":"Description"},{"location":"themes/example-flixnet/#screenshot","text":"This should be below everything else on the screen -- in fact, if you look at the image at the beginning of this guide, it's actually going into the bottom-half region of the screen, reaching the row of images. As it's under everything else, I'll put its implementation at the top of the theme file, even before the collection PathView. I'll anchor the top and left edges of the image to the top right corner of the screen. To make it go slightly into the bottom half, I'll anchor the bottom edge to the vertical center of the screen, then add a small amount of negative margin to the bottom (a positive margin reduces the size of the element, while a negative one increases it). Image { id: screenshot asynchronous: true fillMode: Image . PreserveAspectFit // set the first screenshot as source, or nothing source: api . currentGame . assets . screenshots [ 0 ] || sourceSize { width: 512 ; height: 512 } anchors.top: parent . top anchors.right: parent . right anchors.bottom: parent . verticalCenter anchors.bottomMargin: vpx ( - 45 ) // the height of the collection label } Note Using negative margins kind of feels like a hack though, so depending on the situation you might prefer to use simple width/height properties. Help The screenshots are stored under assets.screenshots , which is a regular JavaScript Array . If it's empty, screenshots[0] will be undefined , and setting an undefined value as the source of an Image will produce a warning in the log. Setting it to an empty string, however, will not, so appending || as a fallback will silence the warning. An alternative solution could be is to use screenshots as a model in eg. a ListView, and the Image as delegate. You could then further extend it to periodically change the current visible screenshot. Tip You can also use the z property of the components to set their relative \"height\".","title":"Screenshot"},{"location":"themes/example-flixnet/#gradients","text":"There are two linear gradients (\"fade-ins\"), one from the left and one from the bottom of the image. Such effect can be added just like regular components, can be positioned, sized, animated, etc. But first of all, to use gradients you'll need the QtGraphicalEffects QML module: import QtQuick 2.0 import QtGraphicalEffects 1.0 FocusScope { // ... } Then, create the horizontal linear gradient inside our Image component: Image { id: screenshot // ... LinearGradient { width: parent . width * 0.25 height: parent . height anchors.left: parent . left // since it goes straight horizontally from the left, // the Y of the point doesn t really matter start: Qt . point ( 0 , 0 ) end: Qt . point ( width , 0 ) // at the left side (0%), it starts with a fully visible black // at the right side (100%), it blends into transparency gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } } And another for the bottom: LinearGradient { width: parent . width height: vpx ( 50 ) anchors.bottom: parent . bottom // goes straight up, so the X of the point doesn t really matter start: Qt . point ( 0 , height ) end: Qt . point ( 0 , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } And we're done!","title":"Gradients"},{"location":"themes/example-flixnet/#selection-marker","text":"Perhaps not easy to notice on the example images, but actually there's a white rectangular border around the current item's place on the topmost horizontal axis. It's position is fixed and does not move even during scrolling. I'll create an empty, border-only Rectangle for it. Since it's over everything else in the theme, I'll put it to the bottom of the whole file, after the gameAxisDelegate 's definition. Rectangle { id: selectionMarker width: vpx ( 240 ) height: vpx ( 135 ) color: transparent border { width: 3 ; color: white } anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) anchors.top: parent . verticalCenter anchors.topMargin: vpx ( 45 ) }","title":"Selection marker"},{"location":"themes/example-flixnet/#opacity","text":"The currently active horizontal row is fully visible, while the rest are a bit darker. I'll set the opacity of the non-active rows to 60%. In addition, I'll add a light animation, so instead of a sudden change in the visibility, the rows gradually raise their opacity during scrolling. Simply add these two lines to the collectionAxisDelegate : Component { id: collectionAxisDelegate Item { // JS functions // width, height opacity: PathView . isCurrentItem ? 1.0 : 0.6 Behavior on opacity { NumberAnimation { duration: 150 } } // ... } }","title":"Opacity"},{"location":"themes/example-flixnet/#done","text":"With all these components added, it seems we're actually done! Here's the end result: And the full code: The code so far #3 import QtQuick 2.0 import QtGraphicalEffects 1.0 FocusScope { Image { id: screenshot asynchronous: true fillMode: Image . PreserveAspectFit source: api . currentGame . assets . screenshots [ 0 ] || sourceSize { width: 512 ; height: 512 } anchors.top: parent . top anchors.right: parent . right anchors.bottom: parent . verticalCenter anchors.bottomMargin: vpx ( - 45 ) LinearGradient { width: parent . width * 0.25 height: parent . height anchors.left: parent . left start: Qt . point ( 0 , 0 ) end: Qt . point ( width , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } LinearGradient { width: parent . width height: vpx ( 50 ) anchors.bottom: parent . bottom start: Qt . point ( 0 , height ) end: Qt . point ( 0 , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } } Text { id: title text: api . currentGame . title color: white font.pixelSize: vpx ( 32 ) font.family: globalFonts . sans font.bold: true anchors.top: parent . top anchors.topMargin: vpx ( 42 ) anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } Row { id: detailsRow anchors.top: title . bottom anchors.topMargin: vpx ( 5 ) anchors.left: title . left spacing: vpx ( 10 ) Item { id: rating visible: api . currentGame . rating 0.0 height: vpx ( 16 ) width: height * 5 Image { anchors.fill: parent source: assets/star_empty.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } Image { anchors.top: parent . top anchors.left: parent . left width: parent . width * api . currentGame . rating height: parent . height source: assets/star_filled.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Text { id: year visible: api . currentGame . year 0 text: api . currentGame . year color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } Rectangle { id: multiplayer width: smileys . width + vpx ( 8 ) height: smileys . height + vpx ( 5 ) color: #555 radius: vpx ( 3 ) visible: api . currentGame . players 1 Image { id: smileys width: vpx ( 13 ) * api . currentGame . players height: vpx ( 13 ) anchors.centerIn: parent source: assets/smiley.svg sourceSize { width: smileys . height ; height: smileys . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Text { id: developer text: api . currentGame . developer color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Text { id: description text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignJustify elide: Text . ElideRight anchors { left: detailsRow . left right: parent . horizontalCenter top: detailsRow . bottom ; topMargin: vpx ( 20 ) bottom: parent . verticalCenter ; bottomMargin: vpx ( 32 ) } } PathView { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom model: api . collectionList . model currentIndex: api . collectionList . index delegate: collectionAxisDelegate snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange clip: true pathItemCount: 1 + Math . ceil ( height / vpx ( 180 )) path: Path { startX: collectionAxis . width * 0.5 startY: vpx ( 180 ) * - 0.5 PathLine { x: collectionAxis . path . startX y: collectionAxis . path . startY + collectionAxis . pathItemCount * vpx ( 180 ) } } preferredHighlightBegin: 1 / pathItemCount preferredHighlightEnd: preferredHighlightBegin focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } Component { id: collectionAxisDelegate Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } width: PathView . view . width height: vpx ( 180 ) opacity: PathView . isCurrentItem ? 1.0 : 0.6 Behavior on opacity { NumberAnimation { duration: 150 } } Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans font.bold: true height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } PathView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: gameAxisDelegate snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange pathItemCount: 2 + Math . ceil ( width / vpx ( 250 )) path: Path { startX: vpx ( 220 ) - vpx ( 250 ) * 2 startY: vpx ( 135 ) * 0.5 PathLine { x: gameAxis . path . startX + gameAxis . pathItemCount * vpx ( 250 ) y: gameAxis . path . startY } } preferredHighlightBegin: 2 / pathItemCount preferredHighlightEnd: preferredHighlightBegin } } } Component { id: gameAxisDelegate Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 visible: image . status !== Image . Ready Text { text: modelData . title anchors.fill: parent anchors.margins: vpx ( 12 ) horizontalAlignment: Text . AlignHCenter verticalAlignment: Text . AlignVCenter wrapMode: Text . Wrap color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Image { id: image anchors.fill: parent visible: source fillMode: Image . PreserveAspectCrop asynchronous: true source: assets . banner || assets . steam || assets . boxFront sourceSize { width: 256 ; height: 256 } } } } Rectangle { id: selectionMarker width: vpx ( 240 ) height: vpx ( 135 ) color: transparent border { width: 3 ; color: white } anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) anchors.top: parent . verticalCenter anchors.topMargin: vpx ( 45 ) } } It's a bit long, but then again this theme had some complex layouting going on. A possible separation to multiple QML files would look like this: Screenshot.qml import QtQuick 2.0 import QtGraphicalEffects 1.0 Image { asynchronous: true fillMode: Image . PreserveAspectFit source: api . currentGame . assets . screenshots [ 0 ] || sourceSize { width: 512 ; height: 512 } LinearGradient { width: parent . width * 0.25 height: parent . height anchors.left: parent . left start: Qt . point ( 0 , 0 ) end: Qt . point ( width , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } LinearGradient { width: parent . width height: vpx ( 50 ) anchors.bottom: parent . bottom start: Qt . point ( 0 , height ) end: Qt . point ( 0 , 0 ) gradient: Gradient { GradientStop { position: 0.0 ; color: black } GradientStop { position: 1.0 ; color: transparent } } } } Title.qml import QtQuick 2.0 Text { text: api . currentGame . title color: white font.pixelSize: vpx ( 32 ) font.family: globalFonts . sans font.bold: true } Rating.qml import QtQuick 2.0 Item { visible: api . currentGame . rating 0.0 height: vpx ( 16 ) width: height * 5 Image { anchors.fill: parent source: assets/star_empty.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } Image { anchors.top: parent . top anchors.left: parent . left width: parent . width * api . currentGame . rating height: parent . height source: assets/star_filled.svg sourceSize { width: parent . height ; height: parent . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } ReleaseYear.qml import QtQuick 2.0 Text { visible: api . currentGame . year 0 text: api . currentGame . year color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } MultiplayerIcon.qml import QtQuick 2.0 Rectangle { width: smileys . width + vpx ( 8 ) height: smileys . height + vpx ( 5 ) color: #555 radius: vpx ( 3 ) visible: api . currentGame . players 1 Image { id: smileys width: vpx ( 13 ) * api . currentGame . players height: vpx ( 13 ) anchors.centerIn: parent source: assets/smiley.svg sourceSize { width: smileys . height ; height: smileys . height } fillMode: Image . TileHorizontally horizontalAlignment: Image . AlignLeft } } Description.qml import QtQuick 2.0 Text { text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignJustify elide: Text . ElideRight } CollectionAxis.qml import QtQuick 2.0 PathView { id: collectionAxis model: api . collectionList . model currentIndex: api . collectionList . index delegate: CollectionAxisDelegate { } snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange clip: true pathItemCount: 1 + Math . ceil ( height / vpx ( 180 )) path: Path { startX: collectionAxis . width * 0.5 startY: vpx ( 180 ) * - 0.5 PathLine { x: collectionAxis . path . startX y: collectionAxis . path . startY + collectionAxis . pathItemCount * vpx ( 180 ) } } preferredHighlightBegin: 1 / pathItemCount preferredHighlightEnd: preferredHighlightBegin focus: true Keys.onUpPressed: api . collectionList . decrementIndex () Keys.onDownPressed: api . collectionList . incrementIndex () Keys.onLeftPressed: currentItem . selectPrev () Keys.onRightPressed: currentItem . selectNext () Keys.onReturnPressed: api . currentGame . launch () } CollectionAxisDelegate.qml import QtQuick 2.0 Item { function selectNext () { modelData . gameList . incrementIndex (); } function selectPrev () { modelData . gameList . decrementIndex (); } width: PathView . view . width height: vpx ( 180 ) opacity: PathView . isCurrentItem ? 1.0 : 0.6 Behavior on opacity { NumberAnimation { duration: 150 } } Text { id: label text: modelData . name color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans font.bold: true height: vpx ( 45 ) verticalAlignment: Text . AlignVCenter anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } PathView { id: gameAxis anchors.left: parent . left anchors.right: parent . right anchors.top: label . bottom anchors.bottom: parent . bottom model: modelData . gameList . model currentIndex: modelData . gameList . index delegate: GameAxisDelegate { } snapMode: PathView . SnapOneItem highlightRangeMode: PathView . StrictlyEnforceRange pathItemCount: 2 + Math . ceil ( width / vpx ( 250 )) path: Path { startX: vpx ( 220 ) - vpx ( 250 ) * 2 startY: vpx ( 135 ) * 0.5 PathLine { x: gameAxis . path . startX + gameAxis . pathItemCount * vpx ( 250 ) y: gameAxis . path . startY } } preferredHighlightBegin: 2 / pathItemCount preferredHighlightEnd: preferredHighlightBegin } } GameAxisDelegate.qml import QtQuick 2.0 Item { width: vpx ( 240 ) height: vpx ( 135 ) Rectangle { anchors.fill: parent color: #333 visible: image . status !== Image . Ready Text { text: modelData . title anchors.fill: parent anchors.margins: vpx ( 12 ) horizontalAlignment: Text . AlignHCenter verticalAlignment: Text . AlignVCenter wrapMode: Text . Wrap color: white font.pixelSize: vpx ( 16 ) font.family: globalFonts . sans } } Image { id: image anchors.fill: parent visible: source fillMode: Image . PreserveAspectCrop asynchronous: true source: assets . banner || assets . steam || assets . boxFront sourceSize { width: 256 ; height: 256 } } } SelectionMarker.qml import QtQuick 2.0 Rectangle { width: vpx ( 240 ) height: vpx ( 135 ) color: transparent border { width: 3 ; color: white } } theme.qml import QtQuick 2.0 FocusScope { Screenshot { id: screenshot anchors.top: parent . top anchors.right: parent . right anchors.bottom: parent . verticalCenter anchors.bottomMargin: vpx ( - 45 ) } Title { id: title anchors.top: parent . top anchors.topMargin: vpx ( 42 ) anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) } Row { id: detailsRow anchors.top: title . bottom anchors.topMargin: vpx ( 5 ) anchors.left: title . left spacing: vpx ( 10 ) Rating { } ReleaseYear { } MultiplayerIcon { } Developer { } } Description { id: description anchors { left: detailsRow . left right: parent . horizontalCenter top: detailsRow . bottom ; topMargin: vpx ( 20 ) bottom: parent . verticalCenter ; bottomMargin: vpx ( 32 ) } } CollectionAxis { id: collectionAxis anchors.left: parent . left anchors.right: parent . right anchors.top: parent . verticalCenter anchors.bottom: parent . bottom } SelectionMarker { anchors.left: parent . left anchors.leftMargin: vpx ( 100 ) anchors.top: parent . verticalCenter anchors.topMargin: vpx ( 45 ) } } theme.cfg name : Flixnet tutorial author : M\u00e1ty\u00e1s Mustoha","title":"Done!"},{"location":"themes/example-simple/","text":"Warning This tutorial is a bit outdated. Certain API commands have changed, so the code blocks below may not work out of the box. However the general ideas still hold, so this might be useful for learning QML itself. Step by step: Simple theme In this tutorial, I'll show the theme creation in practice by implementing the theme above from scratch. Before we start, you might want to be familiar with the QML basics and dynamic layout elements (see the QML tutorials ). The theme has the list of games on the left, in a scrollable menu, with the collection's logo above it. Then some basic information is shown on the right, like title, developer, release year, description, and also a box art. Let's get started! Initial files I'm on Linux, so my theme directory is at ~/.config/pegasus-frontend/themes . I'm creating a new directory called tutorial-simple , and in it my theme.cfg , like this: name : Simple theme author : M\u00e1ty\u00e1s Mustoha and the basic theme.qml : import QtQuick 2.0 FocusScope { } Now I open Pegasus and select this theme on the Settings screen. I'll keep Pegasus open during the development, and refresh the theme with the F5 key after changes. I also open the main log file ~/.config/pegasus-frontend/lastrun.log which will tell me if I've made any errors in the QML file. Tip You can use whatever text editor you like. Qt Creator is cross platform, has good auto-complete and syntax highlight features. For a more lightweight editor, Sublime Text with the QML package, Atom or Notepad++ could be used, among others. Note You might see .qmlc files popping up in your theme's directory. These are cache files, generated for faster loading. When copying the theme to a different machine, you don't have to bring them, they'll automatically get generated the next time you launch Pegasus. Base layout The theme consists of a left and right main panel, so I'll start by adding them first. The left menu panel will take 1/3 of the whole screen, and have a lighter gray color. The right panel will be darker and take the rest of the screen. import QtQuick 2.0 FocusScope { Rectangle { id: menu color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom } Rectangle { id: content color: #222 anchors.left: menu . right anchors.right: parent . right anchors.top: parent . top anchors.bottom: parent . bottom } } Help Using anchors you can define the position and size of elements relative to each other; see anchoring . If you now refresh Pegasus, you'll now see that the screen has been divided between the two shades of gray. You can also see the width of the left panel changing automatically when you resize the application's window. Left panel Lt's continue with the menu panel, as this will be the more complex part of the theme. I'd like to add a 50px padding around the contents of the left panel. But the players have all kinds of screens and devices, with larger or smaller resolutions -- how can I define it in a resolution-independent way? You can define values using percentages, like we did with the width earlier, but for cases where more precision is desired, the vpx function might be of use. These virtual pixel values will automatically scale up or down depending on the screen resolution: a vpx(60) value will turn into 60px on a 720p screen, 90 real pixels on 1080p and 40 on 480p, while keeping the aspect ratio. Combining them with anchors and regular percentages, you can define and position elements in a quite detailed way. So, I want to add a 50px padding for the items -- and by this, I mean a padding that will be 50px on a screen with 1280x720 resolution, and scale up or down for other sizes. For later use, I'll store the amount of the remaining \"content width\" in a property: Rectangle { id: menu property real contentWidth: width - vpx ( 100 ) color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom } Collection logo Lets's add the collection's logo to the panel. First of all you'll need a bunch of game system logo images. I've borrowed them from EmulationStation (original: Nils Bonenberger, CC-BY-NC-SA), except the RetroPie logo (original: Florian M\u00fcller, CC-BY-NC-SA). You can get them here . The file names match the system names from EmulationStation. Simply create a new directory inside your theme's folder, eg. assets , and extract them there. After that, I add an Image element inside the menu Rectangle: Rectangle { id: menu property real contentWidth: width - vpx ( 100 ) color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom Image { id: collectionLogo width: parent . contentWidth height: vpx ( 60 ) fillMode: Image . PreserveAspectFit source: assets/ + api . currentCollection . shortname + .svg asynchronous: true anchors.horizontalCenter: parent . horizontalCenter anchors.top: parent . top anchors.topMargin: vpx ( 50 ) } } Some interesting things here: api is a globally accessible object through which you can access every game and collection data. Its contents are described on the API reference page. source is the concatenation of three strings, shortname being the short name for a collection (eg. nes , gba , ...). asynchronous will load the image in the background. By default ( false ), the program will wait until the Image is fully loaded, but during this time it cannot respond to user input. Since images may take a long time to load depending on the device, asynchronous loading is preferred in most cases. Changing collections Pressing left or right feels kind of natural to use for selecting the next/previous collection. The CollectionList item of the API provides the functions called incrementIndex() and decrementIndex() , which we call for this. I'll handle of the Left and Right keys the top of the whole FocusScope, and simply call these two functions: import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Rectangle { // ... } Rectangle { // ... } } After a refresh, pressing Left and Right should now change the logo on the screen. Yay! Note Assuming you have more than one collection, of course. Tip Handling keyboard keys also enables gamepad navigation. See the controls page about how keys and buttons are related. Game list This is going to be actually the most complex piece of the theme. The games for the currently selected collection can be accessed via api.currentCollection.gameList , with gameList.model being the list of games, gameList.current the currently selected game (also available as api.currentGame ) and gameList.index the index of the selected element. The index can be set manually to a number, or changed by the increment/decrement functions, similarly to the collections. Returning to the menu Rectangle, I add a ListView after the logo, first setting just the dimensions: Rectangle { id: menu // ... Image { /* ... */ } ListView { id: gameView width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) } } Now to actually see something, ListView needs a Model: a list of items, and a Delegate: the definition of how one item should look like on the screen. Our model will be the games of the currently selected collection, and for every game, the visual representation will be a text item: ListView { id: gameView model: api . currentCollection . gameList . model delegate: Text { text: modelData . title } // anchors, etc. } You should now see the list of games, changing with the selected collection on pressing Left / Right . Note gameList.model is a list of Game objects. modelData in the delegate will be one Game object of the Model. I'll do two quick reorganization in the code: typing api.currentCollection.gameList. something every time is a bit long, so I create a property as a shortcut I move the Delegate definition to a separate object to make the code cleaner Rectangle { id: menu // ... Image { /* ... */ } ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) } Component { id: gameViewDelegate Text { text: modelData . title } } } Tip Component is a special element that defines a QML document. Just as QML files can have only one root element, Components can have only one child. You could actually move the Text to a separate file (eg. GameListItem.qml ) and use the file's name to set the delegate (eg. delegate: GameListItem { } ). Let's continue with tweaking the menu items: Component { id: gameViewDelegate Text { text: modelData . title // white, 20px, condensed font color: white font.family: globalFonts . condensed font.pixelSize: vpx ( 20 ) // the size of the whole text box, // a bit taller than the text size for a nice padding width: ListView . view . width height: vpx ( 36 ) // align the text vertically in the middle of the text area verticalAlignment: Text . AlignVCenter // if the text is too long, end it with ellipsis (three dots) elide: Text . ElideRight } } This is how it should look like: To see which one of the menu items is the selected one, I'll change its color and make it bigger and bold: Component { id: gameViewDelegate Text { text: modelData . title // orange if this item is the currently selected one, white otherwise color: ListView . isCurrentItem ? orange : white font.family: globalFonts . condensed // bigger if selected font.pixelSize: ListView . isCurrentItem ? vpx ( 24 ) : vpx ( 20 ) // bold if selected (hint: isCurrentItem is already a true/false value) font.bold: ListView . isCurrentItem width: ListView . view . width height: vpx ( 36 ) verticalAlignment: Text . AlignVCenter elide: Text . ElideRight } } Help When setting values, the X ? A : B form is called \"inline-if\": if the condition X is true, A will be used, otherwise B . In our case, it would equal to the following JavaScript code: if ( ListView . isCurrentItem ) return orange else return white (which you can also use, if you wish). Game selection You should now see one item being highlighted on the list. Now, to make the game selection work, we have to do two thing: make the ListView's index track the current game list's index change the game list index on pressing Up or Down To update the list when the index in the API changes, bind gameList.index to the ListView's currentIndex : ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) } While for the user input, call the index increment/decrement function of the current game list, like we did with the collection changing. At the top of our file: import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Keys.onUpPressed: api . currentCollection . gameList . decrementIndexNoWrap () Keys.onDownPressed: api . currentCollection . gameList . incrementIndexNoWrap () Rectangle { // ... } Rectangle { // ... } } Tip There's a wrapping and a non-wrapping variant of the index changing functions. Use whichever is maching for your themes. Note Of course, you can put the key handling somewhere else, I've merely found it convenient there. Just make sure the item in which you put it has the active focus (eg. has focus: true ). The list should now scroll around with a visible highlight for the current selection. Launching games The last feature required to make our theme functional is launching games. Game objects from the API have a launch() command you can call -- in the most common case, all you need to do is calling api.currentGame.launch() . Simply call it on Enter : import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Keys.onUpPressed: api . currentCollection . gameList . decrementIndexNoWrap () Keys.onDownPressed: api . currentCollection . gameList . incrementIndexNoWrap () Keys.onReturnPressed: api . currentGame . launch () Rectangle { // ... } Rectangle { // ... } } Help Technically the Enter next to the letter keys is called \"Return\", and the one on the numeric pad is \"Enter\". Careful not to mix them up. And with this, we have a functional theme! Tweaks Some additional (and optional) graphical tweaks to try out for extra fancyness. Clipping While scrolling, you might have noticed that items at the top and the bottom of the list seem to go out of the bounds of the ListView's area. Delegates are fully drawn on the screen if they are at least partially visible; to make sure nothing shows up outside the ListView's area, you can use the clip property: ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true } Now the ListView will cut the drawing at its borders. Centering the current item It'd be nice if the currently selected item would try to stay in the middle of the list: We can set this by defining the \"highlight range\"; the ListView will then try to scroll the list so the currently selected item falls into this range. The highlight range is defined by the start and end position. For our vertical ListView, these are the distances from the top edge of the item, in pixels. We can get the vertical center of the ListView simply as height / 2 , and the height of one Text item was set to 36px previously. To position it exactly in the middle, I'll set the start of the range 18px above the center, and end it 18px below. ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index highlightRangeMode: ListView . ApplyRange preferredHighlightBegin: height * 0.5 - vpx ( 18 ) preferredHighlightEnd: height * 0.5 + vpx ( 18 ) width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true } which should give the desired result. However, when you change the collection, there is a few seconds of scrolling to the index of the newly selected game list. To disable this, and jump to the selected item instantly, set animation duration to zero: ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index highlightRangeMode: ListView . ApplyRange highlightMoveDuration: 0 preferredHighlightBegin: height * 0.5 - vpx ( 18 ) preferredHighlightEnd: height * 0.5 + vpx ( 18 ) width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true } Game information With the game selection menu done, let's continue with the right side of the theme, the game informations. Metadata and assets of the currently selected game will be shown here; unlike the dynamic menu, these will be simple Text and Image objects, with their content coming from the API. We'll show the following information, in order: box art game title developer and release year (in one row) game description Box art Add an Image object to the right side panel, with its source set to the current game's box art asset. The image will take the upper half of the screen, with a 50px padding around. As the box arts of different games may have different shapes (portrait, landscape, extra wide, etc.), it might be useful to define the maximum area an image may take up, and fit them in this area. Rectangle { id: content color: #222 anchors.left: menu . right anchors.right: parent . right anchors.top: parent . top anchors.bottom: parent . bottom Image { id: cover anchors.top: parent . top anchors.right: parent . right anchors.left: parent . left anchors.margins: vpx ( 50 ) anchors.bottom: parent . verticalCenter anchors.bottomMargin: 0 fillMode: Image . PreserveAspectFit horizontalAlignment: Image . AlignRight source: api . currentGame . assets . boxFront sourceSize { width: 1024 ; height: 1024 } asynchronous: true } } Box art images might be quite big in resolution, so this time I've also set sourceSize : it limits the maximum amount of memory the image will take up. If the image is largen than this, it will be scaled down, keeping the aspect ratio. In this particular case, I've set it to scale down to 1024 1024 pixels (taking up about/at most 1024 1024 3 bytes = 3 MiB space in the memory). Column and Row The QML Column and Row object are great tools for aligning a fixed number of elements. In this case, the box art and the further Text items could be put into a Column that would anchors.fill its parent with a 50px anchors.margin , so I wouldn't have to define it for the Image itself and the other Texts. So why I didn't use it? Column and Row works the best when the spacing between the elements is the same, but in this theme, I'd like to set some custom spacing between the elements later. An alternative would be to put the elements into an Item. Perhaps you might want to try it as a practice? Title The rest of the game informations will be simple Text objects. The only thing that needs more attention is that the texts may be too long to fit on the screen, so we'll define a text area (similarly to the box art), and hide what doesn't fit into them. So, for the title: Rectangle { id: content // ... Image { /* ... */ } Text { id: title text: api . currentGame . title // white, big bold sans-serif font color: white font.family: globalFonts . sans font.pixelSize: vpx ( 42 ) font.bold: true horizontalAlignment: Text . AlignRight // if it s too long, end it with an ellipsis elide: Text . ElideRight // 40px below the box art anchors.top: cover . bottom anchors.topMargin: vpx ( 40 ) // left and right edges same as the image anchors.left: cover . left anchors.right: cover . right } } Developer and release I'll put two Text items in a Row, and move the Row under the title. I didn't bother wth a maximum text width here, as company names tend to be not too long, while the release year should be just four numbers. The code: Rectangle { id: content // ... Row { id: shortInfo anchors.top: title . bottom anchors.right: title . right spacing: vpx ( 10 ) Text { text: api . currentGame . developer color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans } Text { text: api . currentGame . year color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans visible: api . currentGame . year 0 // !! } } } Note that I only show the year when it's greater than 0. If we have no information about when the game was released, Game .year will be 0, which looks silly on the screen. Description A multiline text area. If the game has a short summar, it'll show that, otherwise the detailed description (or stay empty if none is available). Rectangle { id: content // ... Text { id: description text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignRight elide: Text . ElideRight anchors.top: shortInfo . bottom anchors.topMargin: vpx ( 40 ) anchors.bottom: parent . bottom anchors.bottomMargin: vpx ( 50 ) anchors.left: cover . left anchors.right: cover . right } } Conclusion With all these changes, our theme is now complete and should look like this: Sure, perhaps not the most attractive yet, but I hope it helped learning theme creation. Feel free to tweak it to you liking, or make a new one based on it. Have fun! Full code Here is the full code, as one file. In real projects though, you might prefer to split your theme into multiple files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Keys.onUpPressed: api . currentCollection . gameList . decrementIndexNoWrap () Keys.onDownPressed: api . currentCollection . gameList . incrementIndexNoWrap () Keys.onReturnPressed: api . currentGame . launch () Rectangle { id: menu property real contentWidth: width - vpx ( 100 ) color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom Image { id: collectionLogo width: parent . contentWidth height: vpx ( 60 ) fillMode: Image . PreserveAspectFit source: assets/ + api . currentCollection . shortname + .svg asynchronous: true anchors.horizontalCenter: parent . horizontalCenter anchors.top: parent . top anchors.topMargin: vpx ( 50 ) } ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentIndex: gameList . index highlightRangeMode: ListView . ApplyRange highlightMoveDuration: 0 preferredHighlightBegin: height * 0.5 - vpx ( 18 ) preferredHighlightEnd: height * 0.5 + vpx ( 18 ) width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true } Component { id: gameViewDelegate Text { text: modelData . title color: ListView . isCurrentItem ? orange : white font.family: globalFonts . condensed font.pixelSize: ListView . isCurrentItem ? vpx ( 24 ) : vpx ( 20 ) font.bold: ListView . isCurrentItem width: ListView . view . width height: vpx ( 36 ) verticalAlignment: Text . AlignVCenter elide: Text . ElideRight } } } Rectangle { id: content color: #222 anchors.left: menu . right anchors.right: parent . right anchors.top: parent . top anchors.bottom: parent . bottom Image { id: cover anchors.top: parent . top anchors.right: parent . right anchors.left: parent . left anchors.margins: vpx ( 50 ) anchors.bottom: parent . verticalCenter anchors.bottomMargin: 0 fillMode: Image . PreserveAspectFit horizontalAlignment: Image . AlignRight source: api . currentGame . assets . boxFront sourceSize { width: 1024 ; height: 1024 } asynchronous: true } Text { id: title text: api . currentGame . title color: white font.family: globalFonts . sans font.pixelSize: vpx ( 42 ) font.bold: true horizontalAlignment: Text . AlignRight elide: Text . ElideRight anchors.top: cover . bottom anchors.topMargin: vpx ( 40 ) anchors.left: cover . left anchors.right: cover . right } Row { id: shortInfo anchors.top: title . bottom anchors.right: title . right spacing: vpx ( 10 ) Text { text: api . currentGame . developer color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans } Text { text: api . currentGame . year color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans visible: api . currentGame . year 0 } } Text { id: description text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignRight elide: Text . ElideRight anchors.top: shortInfo . bottom anchors.topMargin: vpx ( 40 ) anchors.bottom: parent . bottom anchors.bottomMargin: vpx ( 50 ) anchors.left: cover . left anchors.right: cover . right } } }","title":"Example -- Simple theme"},{"location":"themes/example-simple/#step-by-step-simple-theme","text":"In this tutorial, I'll show the theme creation in practice by implementing the theme above from scratch. Before we start, you might want to be familiar with the QML basics and dynamic layout elements (see the QML tutorials ). The theme has the list of games on the left, in a scrollable menu, with the collection's logo above it. Then some basic information is shown on the right, like title, developer, release year, description, and also a box art. Let's get started!","title":"Step by step: Simple theme"},{"location":"themes/example-simple/#initial-files","text":"I'm on Linux, so my theme directory is at ~/.config/pegasus-frontend/themes . I'm creating a new directory called tutorial-simple , and in it my theme.cfg , like this: name : Simple theme author : M\u00e1ty\u00e1s Mustoha and the basic theme.qml : import QtQuick 2.0 FocusScope { } Now I open Pegasus and select this theme on the Settings screen. I'll keep Pegasus open during the development, and refresh the theme with the F5 key after changes. I also open the main log file ~/.config/pegasus-frontend/lastrun.log which will tell me if I've made any errors in the QML file. Tip You can use whatever text editor you like. Qt Creator is cross platform, has good auto-complete and syntax highlight features. For a more lightweight editor, Sublime Text with the QML package, Atom or Notepad++ could be used, among others. Note You might see .qmlc files popping up in your theme's directory. These are cache files, generated for faster loading. When copying the theme to a different machine, you don't have to bring them, they'll automatically get generated the next time you launch Pegasus.","title":"Initial files"},{"location":"themes/example-simple/#base-layout","text":"The theme consists of a left and right main panel, so I'll start by adding them first. The left menu panel will take 1/3 of the whole screen, and have a lighter gray color. The right panel will be darker and take the rest of the screen. import QtQuick 2.0 FocusScope { Rectangle { id: menu color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom } Rectangle { id: content color: #222 anchors.left: menu . right anchors.right: parent . right anchors.top: parent . top anchors.bottom: parent . bottom } } Help Using anchors you can define the position and size of elements relative to each other; see anchoring . If you now refresh Pegasus, you'll now see that the screen has been divided between the two shades of gray. You can also see the width of the left panel changing automatically when you resize the application's window.","title":"Base layout"},{"location":"themes/example-simple/#left-panel","text":"Lt's continue with the menu panel, as this will be the more complex part of the theme. I'd like to add a 50px padding around the contents of the left panel. But the players have all kinds of screens and devices, with larger or smaller resolutions -- how can I define it in a resolution-independent way? You can define values using percentages, like we did with the width earlier, but for cases where more precision is desired, the vpx function might be of use. These virtual pixel values will automatically scale up or down depending on the screen resolution: a vpx(60) value will turn into 60px on a 720p screen, 90 real pixels on 1080p and 40 on 480p, while keeping the aspect ratio. Combining them with anchors and regular percentages, you can define and position elements in a quite detailed way. So, I want to add a 50px padding for the items -- and by this, I mean a padding that will be 50px on a screen with 1280x720 resolution, and scale up or down for other sizes. For later use, I'll store the amount of the remaining \"content width\" in a property: Rectangle { id: menu property real contentWidth: width - vpx ( 100 ) color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom }","title":"Left panel"},{"location":"themes/example-simple/#collection-logo","text":"Lets's add the collection's logo to the panel. First of all you'll need a bunch of game system logo images. I've borrowed them from EmulationStation (original: Nils Bonenberger, CC-BY-NC-SA), except the RetroPie logo (original: Florian M\u00fcller, CC-BY-NC-SA). You can get them here . The file names match the system names from EmulationStation. Simply create a new directory inside your theme's folder, eg. assets , and extract them there. After that, I add an Image element inside the menu Rectangle: Rectangle { id: menu property real contentWidth: width - vpx ( 100 ) color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom Image { id: collectionLogo width: parent . contentWidth height: vpx ( 60 ) fillMode: Image . PreserveAspectFit source: assets/ + api . currentCollection . shortname + .svg asynchronous: true anchors.horizontalCenter: parent . horizontalCenter anchors.top: parent . top anchors.topMargin: vpx ( 50 ) } } Some interesting things here: api is a globally accessible object through which you can access every game and collection data. Its contents are described on the API reference page. source is the concatenation of three strings, shortname being the short name for a collection (eg. nes , gba , ...). asynchronous will load the image in the background. By default ( false ), the program will wait until the Image is fully loaded, but during this time it cannot respond to user input. Since images may take a long time to load depending on the device, asynchronous loading is preferred in most cases.","title":"Collection logo"},{"location":"themes/example-simple/#changing-collections","text":"Pressing left or right feels kind of natural to use for selecting the next/previous collection. The CollectionList item of the API provides the functions called incrementIndex() and decrementIndex() , which we call for this. I'll handle of the Left and Right keys the top of the whole FocusScope, and simply call these two functions: import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Rectangle { // ... } Rectangle { // ... } } After a refresh, pressing Left and Right should now change the logo on the screen. Yay! Note Assuming you have more than one collection, of course. Tip Handling keyboard keys also enables gamepad navigation. See the controls page about how keys and buttons are related.","title":"Changing collections"},{"location":"themes/example-simple/#game-list","text":"This is going to be actually the most complex piece of the theme. The games for the currently selected collection can be accessed via api.currentCollection.gameList , with gameList.model being the list of games, gameList.current the currently selected game (also available as api.currentGame ) and gameList.index the index of the selected element. The index can be set manually to a number, or changed by the increment/decrement functions, similarly to the collections. Returning to the menu Rectangle, I add a ListView after the logo, first setting just the dimensions: Rectangle { id: menu // ... Image { /* ... */ } ListView { id: gameView width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) } } Now to actually see something, ListView needs a Model: a list of items, and a Delegate: the definition of how one item should look like on the screen. Our model will be the games of the currently selected collection, and for every game, the visual representation will be a text item: ListView { id: gameView model: api . currentCollection . gameList . model delegate: Text { text: modelData . title } // anchors, etc. } You should now see the list of games, changing with the selected collection on pressing Left / Right . Note gameList.model is a list of Game objects. modelData in the delegate will be one Game object of the Model. I'll do two quick reorganization in the code: typing api.currentCollection.gameList. something every time is a bit long, so I create a property as a shortcut I move the Delegate definition to a separate object to make the code cleaner Rectangle { id: menu // ... Image { /* ... */ } ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) } Component { id: gameViewDelegate Text { text: modelData . title } } } Tip Component is a special element that defines a QML document. Just as QML files can have only one root element, Components can have only one child. You could actually move the Text to a separate file (eg. GameListItem.qml ) and use the file's name to set the delegate (eg. delegate: GameListItem { } ). Let's continue with tweaking the menu items: Component { id: gameViewDelegate Text { text: modelData . title // white, 20px, condensed font color: white font.family: globalFonts . condensed font.pixelSize: vpx ( 20 ) // the size of the whole text box, // a bit taller than the text size for a nice padding width: ListView . view . width height: vpx ( 36 ) // align the text vertically in the middle of the text area verticalAlignment: Text . AlignVCenter // if the text is too long, end it with ellipsis (three dots) elide: Text . ElideRight } } This is how it should look like: To see which one of the menu items is the selected one, I'll change its color and make it bigger and bold: Component { id: gameViewDelegate Text { text: modelData . title // orange if this item is the currently selected one, white otherwise color: ListView . isCurrentItem ? orange : white font.family: globalFonts . condensed // bigger if selected font.pixelSize: ListView . isCurrentItem ? vpx ( 24 ) : vpx ( 20 ) // bold if selected (hint: isCurrentItem is already a true/false value) font.bold: ListView . isCurrentItem width: ListView . view . width height: vpx ( 36 ) verticalAlignment: Text . AlignVCenter elide: Text . ElideRight } } Help When setting values, the X ? A : B form is called \"inline-if\": if the condition X is true, A will be used, otherwise B . In our case, it would equal to the following JavaScript code: if ( ListView . isCurrentItem ) return orange else return white (which you can also use, if you wish).","title":"Game list"},{"location":"themes/example-simple/#game-selection","text":"You should now see one item being highlighted on the list. Now, to make the game selection work, we have to do two thing: make the ListView's index track the current game list's index change the game list index on pressing Up or Down To update the list when the index in the API changes, bind gameList.index to the ListView's currentIndex : ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) } While for the user input, call the index increment/decrement function of the current game list, like we did with the collection changing. At the top of our file: import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Keys.onUpPressed: api . currentCollection . gameList . decrementIndexNoWrap () Keys.onDownPressed: api . currentCollection . gameList . incrementIndexNoWrap () Rectangle { // ... } Rectangle { // ... } } Tip There's a wrapping and a non-wrapping variant of the index changing functions. Use whichever is maching for your themes. Note Of course, you can put the key handling somewhere else, I've merely found it convenient there. Just make sure the item in which you put it has the active focus (eg. has focus: true ). The list should now scroll around with a visible highlight for the current selection.","title":"Game selection"},{"location":"themes/example-simple/#launching-games","text":"The last feature required to make our theme functional is launching games. Game objects from the API have a launch() command you can call -- in the most common case, all you need to do is calling api.currentGame.launch() . Simply call it on Enter : import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Keys.onUpPressed: api . currentCollection . gameList . decrementIndexNoWrap () Keys.onDownPressed: api . currentCollection . gameList . incrementIndexNoWrap () Keys.onReturnPressed: api . currentGame . launch () Rectangle { // ... } Rectangle { // ... } } Help Technically the Enter next to the letter keys is called \"Return\", and the one on the numeric pad is \"Enter\". Careful not to mix them up. And with this, we have a functional theme!","title":"Launching games"},{"location":"themes/example-simple/#tweaks","text":"Some additional (and optional) graphical tweaks to try out for extra fancyness.","title":"Tweaks"},{"location":"themes/example-simple/#clipping","text":"While scrolling, you might have noticed that items at the top and the bottom of the list seem to go out of the bounds of the ListView's area. Delegates are fully drawn on the screen if they are at least partially visible; to make sure nothing shows up outside the ListView's area, you can use the clip property: ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true } Now the ListView will cut the drawing at its borders.","title":"Clipping"},{"location":"themes/example-simple/#centering-the-current-item","text":"It'd be nice if the currently selected item would try to stay in the middle of the list: We can set this by defining the \"highlight range\"; the ListView will then try to scroll the list so the currently selected item falls into this range. The highlight range is defined by the start and end position. For our vertical ListView, these are the distances from the top edge of the item, in pixels. We can get the vertical center of the ListView simply as height / 2 , and the height of one Text item was set to 36px previously. To position it exactly in the middle, I'll set the start of the range 18px above the center, and end it 18px below. ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index highlightRangeMode: ListView . ApplyRange preferredHighlightBegin: height * 0.5 - vpx ( 18 ) preferredHighlightEnd: height * 0.5 + vpx ( 18 ) width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true } which should give the desired result. However, when you change the collection, there is a few seconds of scrolling to the index of the newly selected game list. To disable this, and jump to the selected item instantly, set animation duration to zero: ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentItem: gameList . index highlightRangeMode: ListView . ApplyRange highlightMoveDuration: 0 preferredHighlightBegin: height * 0.5 - vpx ( 18 ) preferredHighlightEnd: height * 0.5 + vpx ( 18 ) width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true }","title":"Centering the current item"},{"location":"themes/example-simple/#game-information","text":"With the game selection menu done, let's continue with the right side of the theme, the game informations. Metadata and assets of the currently selected game will be shown here; unlike the dynamic menu, these will be simple Text and Image objects, with their content coming from the API. We'll show the following information, in order: box art game title developer and release year (in one row) game description","title":"Game information"},{"location":"themes/example-simple/#box-art","text":"Add an Image object to the right side panel, with its source set to the current game's box art asset. The image will take the upper half of the screen, with a 50px padding around. As the box arts of different games may have different shapes (portrait, landscape, extra wide, etc.), it might be useful to define the maximum area an image may take up, and fit them in this area. Rectangle { id: content color: #222 anchors.left: menu . right anchors.right: parent . right anchors.top: parent . top anchors.bottom: parent . bottom Image { id: cover anchors.top: parent . top anchors.right: parent . right anchors.left: parent . left anchors.margins: vpx ( 50 ) anchors.bottom: parent . verticalCenter anchors.bottomMargin: 0 fillMode: Image . PreserveAspectFit horizontalAlignment: Image . AlignRight source: api . currentGame . assets . boxFront sourceSize { width: 1024 ; height: 1024 } asynchronous: true } } Box art images might be quite big in resolution, so this time I've also set sourceSize : it limits the maximum amount of memory the image will take up. If the image is largen than this, it will be scaled down, keeping the aspect ratio. In this particular case, I've set it to scale down to 1024 1024 pixels (taking up about/at most 1024 1024 3 bytes = 3 MiB space in the memory). Column and Row The QML Column and Row object are great tools for aligning a fixed number of elements. In this case, the box art and the further Text items could be put into a Column that would anchors.fill its parent with a 50px anchors.margin , so I wouldn't have to define it for the Image itself and the other Texts. So why I didn't use it? Column and Row works the best when the spacing between the elements is the same, but in this theme, I'd like to set some custom spacing between the elements later. An alternative would be to put the elements into an Item. Perhaps you might want to try it as a practice?","title":"Box art"},{"location":"themes/example-simple/#title","text":"The rest of the game informations will be simple Text objects. The only thing that needs more attention is that the texts may be too long to fit on the screen, so we'll define a text area (similarly to the box art), and hide what doesn't fit into them. So, for the title: Rectangle { id: content // ... Image { /* ... */ } Text { id: title text: api . currentGame . title // white, big bold sans-serif font color: white font.family: globalFonts . sans font.pixelSize: vpx ( 42 ) font.bold: true horizontalAlignment: Text . AlignRight // if it s too long, end it with an ellipsis elide: Text . ElideRight // 40px below the box art anchors.top: cover . bottom anchors.topMargin: vpx ( 40 ) // left and right edges same as the image anchors.left: cover . left anchors.right: cover . right } }","title":"Title"},{"location":"themes/example-simple/#developer-and-release","text":"I'll put two Text items in a Row, and move the Row under the title. I didn't bother wth a maximum text width here, as company names tend to be not too long, while the release year should be just four numbers. The code: Rectangle { id: content // ... Row { id: shortInfo anchors.top: title . bottom anchors.right: title . right spacing: vpx ( 10 ) Text { text: api . currentGame . developer color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans } Text { text: api . currentGame . year color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans visible: api . currentGame . year 0 // !! } } } Note that I only show the year when it's greater than 0. If we have no information about when the game was released, Game .year will be 0, which looks silly on the screen.","title":"Developer and release"},{"location":"themes/example-simple/#description","text":"A multiline text area. If the game has a short summar, it'll show that, otherwise the detailed description (or stay empty if none is available). Rectangle { id: content // ... Text { id: description text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignRight elide: Text . ElideRight anchors.top: shortInfo . bottom anchors.topMargin: vpx ( 40 ) anchors.bottom: parent . bottom anchors.bottomMargin: vpx ( 50 ) anchors.left: cover . left anchors.right: cover . right } }","title":"Description"},{"location":"themes/example-simple/#conclusion","text":"With all these changes, our theme is now complete and should look like this: Sure, perhaps not the most attractive yet, but I hope it helped learning theme creation. Feel free to tweak it to you liking, or make a new one based on it. Have fun! Full code Here is the full code, as one file. In real projects though, you might prefer to split your theme into multiple files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 import QtQuick 2.0 FocusScope { Keys.onLeftPressed: api . collectionList . decrementIndex () Keys.onRightPressed: api . collectionList . incrementIndex () Keys.onUpPressed: api . currentCollection . gameList . decrementIndexNoWrap () Keys.onDownPressed: api . currentCollection . gameList . incrementIndexNoWrap () Keys.onReturnPressed: api . currentGame . launch () Rectangle { id: menu property real contentWidth: width - vpx ( 100 ) color: #555 width: parent . width * 0.3 anchors.top: parent . top anchors.bottom: parent . bottom Image { id: collectionLogo width: parent . contentWidth height: vpx ( 60 ) fillMode: Image . PreserveAspectFit source: assets/ + api . currentCollection . shortname + .svg asynchronous: true anchors.horizontalCenter: parent . horizontalCenter anchors.top: parent . top anchors.topMargin: vpx ( 50 ) } ListView { id: gameView property var gameList: api . currentCollection . gameList model: gameList . model delegate: gameViewDelegate currentIndex: gameList . index highlightRangeMode: ListView . ApplyRange highlightMoveDuration: 0 preferredHighlightBegin: height * 0.5 - vpx ( 18 ) preferredHighlightEnd: height * 0.5 + vpx ( 18 ) width: parent . contentWidth anchors.horizontalCenter: parent . horizontalCenter anchors.top: collectionLogo . bottom anchors.bottom: parent . bottom anchors.margins: vpx ( 50 ) clip: true } Component { id: gameViewDelegate Text { text: modelData . title color: ListView . isCurrentItem ? orange : white font.family: globalFonts . condensed font.pixelSize: ListView . isCurrentItem ? vpx ( 24 ) : vpx ( 20 ) font.bold: ListView . isCurrentItem width: ListView . view . width height: vpx ( 36 ) verticalAlignment: Text . AlignVCenter elide: Text . ElideRight } } } Rectangle { id: content color: #222 anchors.left: menu . right anchors.right: parent . right anchors.top: parent . top anchors.bottom: parent . bottom Image { id: cover anchors.top: parent . top anchors.right: parent . right anchors.left: parent . left anchors.margins: vpx ( 50 ) anchors.bottom: parent . verticalCenter anchors.bottomMargin: 0 fillMode: Image . PreserveAspectFit horizontalAlignment: Image . AlignRight source: api . currentGame . assets . boxFront sourceSize { width: 1024 ; height: 1024 } asynchronous: true } Text { id: title text: api . currentGame . title color: white font.family: globalFonts . sans font.pixelSize: vpx ( 42 ) font.bold: true horizontalAlignment: Text . AlignRight elide: Text . ElideRight anchors.top: cover . bottom anchors.topMargin: vpx ( 40 ) anchors.left: cover . left anchors.right: cover . right } Row { id: shortInfo anchors.top: title . bottom anchors.right: title . right spacing: vpx ( 10 ) Text { text: api . currentGame . developer color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans } Text { text: api . currentGame . year color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans visible: api . currentGame . year 0 } } Text { id: description text: api . currentGame . summary || api . currentGame . description color: white font.pixelSize: vpx ( 18 ) font.family: globalFonts . sans wrapMode: Text . WordWrap horizontalAlignment: Text . AlignRight elide: Text . ElideRight anchors.top: shortInfo . bottom anchors.topMargin: vpx ( 40 ) anchors.bottom: parent . bottom anchors.bottomMargin: vpx ( 50 ) anchors.left: cover . left anchors.right: cover . right } } }","title":"Conclusion"},{"location":"themes/overview/","text":"Theme guide Overview Pegasus consists of two layers: the core which looks for your games and metadata, and the user interface (UI), where the data provided by the core can be presented in some form. The two layers are completely separated, which means you have full control about what you put on the screen, where you place assets or text and what kind of animations or effects you use on them. Themes in Pegasus define the look and feel of the whole \"content area\". Themes don't have predefined \"screens\" or fixed layouts, though you can implement them if you want. The goal is to give theme makers all the available tools and components and allow them creating interfaces without further restrictions. QML Themes are written in the QML language. QML (Qt Modeling Language) is a user interface specification language: it describes the components of the theme, their properties, and the hierarchy and relations between them. Technically it's similar to XML, HTML/CSS and the JSON languages. // An example QML document // *QML documents describe an object tree of elements* // Source: https://en.wikipedia.org/wiki/QML import QtQuick 2.0 Rectangle { id: canvas width: 250 height: 200 color: blue Image { id: logo source: pics/logo.png anchors.centerIn: parent x: canvas . height / 5 } } There are numerous built-in components you can use in a theme: simple types (texts, rectangles, images, ...), components that define layouts of other items (rows, grids, custom paths) and special elements (animations, particle effects, timers). These are contained in so called modules , with most of them are in the one called Qt Quick . For learning QML, you can find resources on the QML tutorials page . Extending with JavaScript QML generally describes what is on the screen and how they look like -- to tell what a component should do , you can extend QML with JavaScript code. Don't worry if you aren't familiar with it; QML works quite well on its own, usually you only need to code if you want to implement some special behaviour for the elements. Warning While JavaScript is usually associated with websites, Pegasus is NOT a web browser or an HTML5 app. Only the JavaScript engine is used, not a whole browser. In addition, your code is compiled and cached automatically for better performance. Further reading https://en.wikipedia.org/wiki/QML https://doc.qt.io/qt-5/qtquick-index.html https://doc.qt.io/qt-5/qmlapplications.html Theme directories Pegasus is looking for themes in the configuration directories , under a themes subdirectory (eg. ~/.config/pegasus-frontend/themes/ ). Theme structure Inside these directories, every individual theme is contained in its own directory. The name of this directory doesn't matter, as long as it's unique. Two files are required for every theme: a theme.cfg file that contains information about your theme, like name or description, and a theme.qml which will be the entry point to your QML code (ie. this will be loaded first by Pegasus). theme.cfg The theme.cfg file is used to describe your theme. It's a simple configuration file, in the same format as Pegasus' game metadata files ( todo ). In short: option name: option value defines options [words between brackets] defines groups of options empty lines and lines starting with # (comments) are skipped lines starting with space will be appended to the previous option's value (which you can use for eg. descriptions spanning multiple lines) Here is an example: name : Pegasus Grid author : M\u00e1ty\u00e1s Mustoha version : alpha summary : The default grid theme of Pegasus Currently the following options are recognized: name : the name of your theme (required). Should be short and unique. version : a version identifier; can be a number, text, whatever you like as long as it's unique. author : the author of the theme; either simply a name or in \"name email \" format. summary : a short (max. 80-100 characters) summary. description : a longer description. keywords : keywords used for searching. Separate them with ' , '. homepage : a link to you project's site. Every theme is required to have a theme.cfg file, with at least the name defined. theme.qml The theme.qml file is the entry point of your theme. You should start with the following minimal code: import QtQuick 2.0 FocusScope { // your code here } FocusScope is a special container component in QML which is used for separating keyboard/gamepad input from the other parts of the UI (eg. main menu). FocusScope , as well as the other components and modules will be introduced in the more in-depth QML tutorials . Hello World! Here's a simple \"Hello World\" test theme: import QtQuick 2.0 FocusScope { Text { text: Hello World! color: white anchors.centerIn: parent } } Usage If you've created the theme.cfg and theme.qml files as described above, you should now see your entry in the list of available themes in Pegasus' settings menu. After the theme is loaded, pressing the F5 key will make Pegasus reload its files, making it easier to try out changes. Special QML properties Pegasus' themes are standard QML files, and you can use any QML tutorial (collection here ) to learn it. Pegasus itself provides the following additions: a virtual coordinate system to make multiple aspect ratio support easier the actual collection- and platform data, and the way to select and launch a game Virtual screen coordinates When you load a theme, its main component (the FocusScope above) will be set to fill the whole screen. The top left corner of the screen is (0,0), with the X axis growing right and the Y axis growing downwards. While positioning elements on the screen, you should make sure that your theme works well with multiple aspect ratios and screen resolutions. Generally in QML this isn't hard because you can tell the position and size of elements compared to others using anchors (eg. align an element right above or below to another -- see the QML tutorials ). When you do have to position or size things manually, it is common to use percentages or create different themes for different aspect ratios. For better support of different screen sizes, Pegasus also provides an optional virtual coordinate system . You can treat the screen as one with the resolution of at least 1280x720 virtual pixels (16:9 aspect ratio), and use integer pixel values, which will then scale to the correct physical value according to the screen's real resolution. If the screen's aspect ratio is smaller than 16:9 (eg. 4:3 or 5:4), then the virtual screen will be taller than 720 virtual pixels, but still have 1280 as a fixed width. If the aspect ratio is wider (eg. 21:9), then the virtual height will remain to be 720, but the width will be bigger. This system can be useful when you want to express precise details as integer values, like spacing, text sizes, width/height, etc. To use virtual pixel values, simply put your number inside a function called vpx . For example, instead of width: 50 you would use width: vpx ( 50 ) which will turn into 50 real pixels on a 720p screen, scale up to 150px on a 4K TV, and scale down to 25px on a smaller 360p device. Using virtual pixel values is optional, but often more intuitive than percentages with several digits of precision. Depending on your situations, you might prefer one over the other, or use both of them. Feel free to experiment! Tip Using the virtual coordinate system does not decrease image quality. Game data The actual data set provided by the Core is available in the global object api . Its items are detailed on the API reference page . Next steps QML tutorial collection Step-by-step example: Simple theme Step-by-step example: Flixnet theme","title":"Overview"},{"location":"themes/overview/#theme-guide","text":"","title":"Theme guide"},{"location":"themes/overview/#overview","text":"Pegasus consists of two layers: the core which looks for your games and metadata, and the user interface (UI), where the data provided by the core can be presented in some form. The two layers are completely separated, which means you have full control about what you put on the screen, where you place assets or text and what kind of animations or effects you use on them. Themes in Pegasus define the look and feel of the whole \"content area\". Themes don't have predefined \"screens\" or fixed layouts, though you can implement them if you want. The goal is to give theme makers all the available tools and components and allow them creating interfaces without further restrictions.","title":"Overview"},{"location":"themes/overview/#qml","text":"Themes are written in the QML language. QML (Qt Modeling Language) is a user interface specification language: it describes the components of the theme, their properties, and the hierarchy and relations between them. Technically it's similar to XML, HTML/CSS and the JSON languages. // An example QML document // *QML documents describe an object tree of elements* // Source: https://en.wikipedia.org/wiki/QML import QtQuick 2.0 Rectangle { id: canvas width: 250 height: 200 color: blue Image { id: logo source: pics/logo.png anchors.centerIn: parent x: canvas . height / 5 } } There are numerous built-in components you can use in a theme: simple types (texts, rectangles, images, ...), components that define layouts of other items (rows, grids, custom paths) and special elements (animations, particle effects, timers). These are contained in so called modules , with most of them are in the one called Qt Quick . For learning QML, you can find resources on the QML tutorials page .","title":"QML"},{"location":"themes/overview/#extending-with-javascript","text":"QML generally describes what is on the screen and how they look like -- to tell what a component should do , you can extend QML with JavaScript code. Don't worry if you aren't familiar with it; QML works quite well on its own, usually you only need to code if you want to implement some special behaviour for the elements. Warning While JavaScript is usually associated with websites, Pegasus is NOT a web browser or an HTML5 app. Only the JavaScript engine is used, not a whole browser. In addition, your code is compiled and cached automatically for better performance. Further reading https://en.wikipedia.org/wiki/QML https://doc.qt.io/qt-5/qtquick-index.html https://doc.qt.io/qt-5/qmlapplications.html","title":"Extending with JavaScript"},{"location":"themes/overview/#theme-directories","text":"Pegasus is looking for themes in the configuration directories , under a themes subdirectory (eg. ~/.config/pegasus-frontend/themes/ ).","title":"Theme directories"},{"location":"themes/overview/#theme-structure","text":"Inside these directories, every individual theme is contained in its own directory. The name of this directory doesn't matter, as long as it's unique. Two files are required for every theme: a theme.cfg file that contains information about your theme, like name or description, and a theme.qml which will be the entry point to your QML code (ie. this will be loaded first by Pegasus).","title":"Theme structure"},{"location":"themes/overview/#themecfg","text":"The theme.cfg file is used to describe your theme. It's a simple configuration file, in the same format as Pegasus' game metadata files ( todo ). In short: option name: option value defines options [words between brackets] defines groups of options empty lines and lines starting with # (comments) are skipped lines starting with space will be appended to the previous option's value (which you can use for eg. descriptions spanning multiple lines) Here is an example: name : Pegasus Grid author : M\u00e1ty\u00e1s Mustoha version : alpha summary : The default grid theme of Pegasus Currently the following options are recognized: name : the name of your theme (required). Should be short and unique. version : a version identifier; can be a number, text, whatever you like as long as it's unique. author : the author of the theme; either simply a name or in \"name email \" format. summary : a short (max. 80-100 characters) summary. description : a longer description. keywords : keywords used for searching. Separate them with ' , '. homepage : a link to you project's site. Every theme is required to have a theme.cfg file, with at least the name defined.","title":"theme.cfg"},{"location":"themes/overview/#themeqml","text":"The theme.qml file is the entry point of your theme. You should start with the following minimal code: import QtQuick 2.0 FocusScope { // your code here } FocusScope is a special container component in QML which is used for separating keyboard/gamepad input from the other parts of the UI (eg. main menu). FocusScope , as well as the other components and modules will be introduced in the more in-depth QML tutorials . Hello World! Here's a simple \"Hello World\" test theme: import QtQuick 2.0 FocusScope { Text { text: Hello World! color: white anchors.centerIn: parent } }","title":"theme.qml"},{"location":"themes/overview/#usage","text":"If you've created the theme.cfg and theme.qml files as described above, you should now see your entry in the list of available themes in Pegasus' settings menu. After the theme is loaded, pressing the F5 key will make Pegasus reload its files, making it easier to try out changes.","title":"Usage"},{"location":"themes/overview/#special-qml-properties","text":"Pegasus' themes are standard QML files, and you can use any QML tutorial (collection here ) to learn it. Pegasus itself provides the following additions: a virtual coordinate system to make multiple aspect ratio support easier the actual collection- and platform data, and the way to select and launch a game","title":"Special QML properties"},{"location":"themes/overview/#virtual-screen-coordinates","text":"When you load a theme, its main component (the FocusScope above) will be set to fill the whole screen. The top left corner of the screen is (0,0), with the X axis growing right and the Y axis growing downwards. While positioning elements on the screen, you should make sure that your theme works well with multiple aspect ratios and screen resolutions. Generally in QML this isn't hard because you can tell the position and size of elements compared to others using anchors (eg. align an element right above or below to another -- see the QML tutorials ). When you do have to position or size things manually, it is common to use percentages or create different themes for different aspect ratios. For better support of different screen sizes, Pegasus also provides an optional virtual coordinate system . You can treat the screen as one with the resolution of at least 1280x720 virtual pixels (16:9 aspect ratio), and use integer pixel values, which will then scale to the correct physical value according to the screen's real resolution. If the screen's aspect ratio is smaller than 16:9 (eg. 4:3 or 5:4), then the virtual screen will be taller than 720 virtual pixels, but still have 1280 as a fixed width. If the aspect ratio is wider (eg. 21:9), then the virtual height will remain to be 720, but the width will be bigger. This system can be useful when you want to express precise details as integer values, like spacing, text sizes, width/height, etc. To use virtual pixel values, simply put your number inside a function called vpx . For example, instead of width: 50 you would use width: vpx ( 50 ) which will turn into 50 real pixels on a 720p screen, scale up to 150px on a 4K TV, and scale down to 25px on a smaller 360p device. Using virtual pixel values is optional, but often more intuitive than percentages with several digits of precision. Depending on your situations, you might prefer one over the other, or use both of them. Feel free to experiment! Tip Using the virtual coordinate system does not decrease image quality.","title":"Virtual screen coordinates"},{"location":"themes/overview/#game-data","text":"The actual data set provided by the Core is available in the global object api . Its items are detailed on the API reference page .","title":"Game data"},{"location":"themes/overview/#next-steps","text":"QML tutorial collection Step-by-step example: Simple theme Step-by-step example: Flixnet theme","title":"Next steps"},{"location":"themes/qml-modules/","text":"Available QML modules The following modules are bundled with Pegasus, and can be safely include d in QML files: QtQuick QtQuick.Layouts QtQuick.Particles QtQuick.Window QtCanvas3D QtGamepad QtGraphicalEffects QtMultimedia","title":"QML modules"},{"location":"themes/qml-modules/#available-qml-modules","text":"The following modules are bundled with Pegasus, and can be safely include d in QML files: QtQuick QtQuick.Layouts QtQuick.Particles QtQuick.Window QtCanvas3D QtGamepad QtGraphicalEffects QtMultimedia","title":"Available QML modules"},{"location":"themes/qml-tutorials/","text":"QML tutorial collection This page collects tutorials and guides for learning QML. While the example theme guides are intended to be beginner friendly, I'd recommend reading at least the basics and the dynamic layout topics, which you'll most likely use in a theme. After that, just pick whatever you're interested in and/or look up things in the official documentation. Basics These provide an introduction to the language. After reading them, you should be familiar with: the basic syntax simple elements: Rectangle, Image, Text and Item positioners: Column, Row, Grid, Flow simple transformations: rotate, scale anchoring focus handling key presses with the Keys element Resources: QML ebook chapter 4 Wikipedia QML official tutorial basic types Dynamic layout A theme should be able to show the list of games and collections. An array of data objects is what QML calls \"Model\". You can fully customize how one item should look like on the screen (the \"Delegate\"), and how all these items should be aligned/layed out (the \"View\"). The standard layouts are: ListView : aligns the items on a horizontal or vertical path GridView : fills a grid with the items (either the number rows or the number of colums should be specified) PathView : aligns the items along an arbitrary path Repeater : simply creates the items but doesn't do any further alignment Resources: QML ebook chapter 6 States, transitions, animations You might want to create a theme that consists of multiple states, eg. a platform select screen and an actual game list. Or perhaps you want to simply move an object around in multiple steps or toggle some effects. A State object can be used to set properties of one or more objects at once. The transition between two states can be animated. Animations can also be created for individual properties, or played stand-alone. Resources: QML ebook chapter 5 Media playback You can write a complete media player in QML. The third-party documentation is a bit outdated, so you might want to check the official references too. The most common components are Video, Audio and Playlist. Resources: Multimedia module QML ebook chapter 10 Further resources The elements so far are what you'd commonly use in a theme, however there are still lots of features not covered here, including: touch control and sensors (eg. gyroscope) manual 2D drawing canvas particles and graphical effects (shadow, gradient, blur, ...) 3D scenes custom shader code For further learning, the unofficial QML book might come handy: https://qmlbook.github.io/index.html You can also find a bunch of official documentations here: https://doc.qt.io/qt-5/qmlapplications.html https://doc.qt.io/qt-5/qtquick-index.html https://doc.qt.io/qt-5/qtqml-index.html https://doc.qt.io/qt-5/qml-tutorial.html https://doc.qt.io/qt-5/qtquick-qmlmodule.html This one is a bit old, but might be good for learning the concepts: https://doc.qt.io/archives/qt-4.8/qtquick.html . Visual editor Qt Creator has a drag-and-drop QML editor (the Design tab). Unfortunately I couldn't use it because of crashes, but you might have better luck with it.","title":"QML tutorials"},{"location":"themes/qml-tutorials/#qml-tutorial-collection","text":"This page collects tutorials and guides for learning QML. While the example theme guides are intended to be beginner friendly, I'd recommend reading at least the basics and the dynamic layout topics, which you'll most likely use in a theme. After that, just pick whatever you're interested in and/or look up things in the official documentation.","title":"QML tutorial collection"},{"location":"themes/qml-tutorials/#basics","text":"These provide an introduction to the language. After reading them, you should be familiar with: the basic syntax simple elements: Rectangle, Image, Text and Item positioners: Column, Row, Grid, Flow simple transformations: rotate, scale anchoring focus handling key presses with the Keys element Resources: QML ebook chapter 4 Wikipedia QML official tutorial basic types","title":"Basics"},{"location":"themes/qml-tutorials/#dynamic-layout","text":"A theme should be able to show the list of games and collections. An array of data objects is what QML calls \"Model\". You can fully customize how one item should look like on the screen (the \"Delegate\"), and how all these items should be aligned/layed out (the \"View\"). The standard layouts are: ListView : aligns the items on a horizontal or vertical path GridView : fills a grid with the items (either the number rows or the number of colums should be specified) PathView : aligns the items along an arbitrary path Repeater : simply creates the items but doesn't do any further alignment Resources: QML ebook chapter 6","title":"Dynamic layout"},{"location":"themes/qml-tutorials/#states-transitions-animations","text":"You might want to create a theme that consists of multiple states, eg. a platform select screen and an actual game list. Or perhaps you want to simply move an object around in multiple steps or toggle some effects. A State object can be used to set properties of one or more objects at once. The transition between two states can be animated. Animations can also be created for individual properties, or played stand-alone. Resources: QML ebook chapter 5","title":"States, transitions, animations"},{"location":"themes/qml-tutorials/#media-playback","text":"You can write a complete media player in QML. The third-party documentation is a bit outdated, so you might want to check the official references too. The most common components are Video, Audio and Playlist. Resources: Multimedia module QML ebook chapter 10","title":"Media playback"},{"location":"themes/qml-tutorials/#further-resources","text":"The elements so far are what you'd commonly use in a theme, however there are still lots of features not covered here, including: touch control and sensors (eg. gyroscope) manual 2D drawing canvas particles and graphical effects (shadow, gradient, blur, ...) 3D scenes custom shader code For further learning, the unofficial QML book might come handy: https://qmlbook.github.io/index.html You can also find a bunch of official documentations here: https://doc.qt.io/qt-5/qmlapplications.html https://doc.qt.io/qt-5/qtquick-index.html https://doc.qt.io/qt-5/qtqml-index.html https://doc.qt.io/qt-5/qml-tutorial.html https://doc.qt.io/qt-5/qtquick-qmlmodule.html This one is a bit old, but might be good for learning the concepts: https://doc.qt.io/archives/qt-4.8/qtquick.html .","title":"Further resources"},{"location":"themes/qml-tutorials/#visual-editor","text":"Qt Creator has a drag-and-drop QML editor (the Design tab). Unfortunately I couldn't use it because of crashes, but you might have better luck with it.","title":"Visual editor"},{"location":"user-guide/breaking-changes/","text":"Breaking changes This page list the breaking changes that happened during the development, and how to update between the releases affected. Alpha 11 Alpha 10 Alpha 11, 2019-03. There have been several breaking changes related to the metadata file format and the theme programming interface. What changed Single metadata file: Previously there have been separate files for defining Collections and Games ( collections.txt and metadata.txt ). In Alpha 11, the to files were merged, and both Collections and Games can be defined in the same file. Format changes: Alpha 11 introduced a cleaner difference between text values and item list. The text format was also slightly changed to avoid long descriptions floating unconnected to the rest of the file. Multifile games: In earlier versions of Pegasus, every single file was treated as a separate game, and in the metadata format, games were defined by a file property like this: file : Advance Wars ( USA ). gba title : Advance Wars developer : Intelligent Games genre : Strategy # ... In Alpha 11, support for multifile games was added and so the 1 file 1 game assumption didn't hold anymore. As such, the format was changed so the name of the game comes first, then the files can be listed: game : Final Fantasy VII files : ffvii_disc1.iso ffvii_disc2.iso developer : Square genre : Role - playing # ... Theme API improvements: Alpha 11 added support for theme-side sorting and filtering, custom settings (\"memory\") and access to the list of all available games. How to update Follow these steps for each of your game directories: Make backups of your collections.txt and metadata.txt files. Update the format: Open your metadata.txt in a text editor and copy its contents. Open the metadata converter page. On the left side, select Pegasus (alpha 10) -- metadata.txt and paste the contents to the text area. On the right side, select Pegasus -- metadata.txt . The results of the conversion will appear shortly. Copy the resulting text back to your metadata.txt file, overwriting everything that was in before it previously. Merge collections.txt and metadata.txt : Open both with a text editor, copy the contents of collections.txt and paste it somewhere into metadata.txt (doesn't matter where, but often it's more readable if it's on the top). You can now delete the collections.txt file. Theme developers: You can find a summary of changes here .","title":"Breaking changes"},{"location":"user-guide/breaking-changes/#breaking-changes","text":"This page list the breaking changes that happened during the development, and how to update between the releases affected.","title":"Breaking changes"},{"location":"user-guide/breaking-changes/#alpha-11","text":"Alpha 10 Alpha 11, 2019-03. There have been several breaking changes related to the metadata file format and the theme programming interface.","title":"Alpha 11"},{"location":"user-guide/breaking-changes/#what-changed","text":"Single metadata file: Previously there have been separate files for defining Collections and Games ( collections.txt and metadata.txt ). In Alpha 11, the to files were merged, and both Collections and Games can be defined in the same file. Format changes: Alpha 11 introduced a cleaner difference between text values and item list. The text format was also slightly changed to avoid long descriptions floating unconnected to the rest of the file. Multifile games: In earlier versions of Pegasus, every single file was treated as a separate game, and in the metadata format, games were defined by a file property like this: file : Advance Wars ( USA ). gba title : Advance Wars developer : Intelligent Games genre : Strategy # ... In Alpha 11, support for multifile games was added and so the 1 file 1 game assumption didn't hold anymore. As such, the format was changed so the name of the game comes first, then the files can be listed: game : Final Fantasy VII files : ffvii_disc1.iso ffvii_disc2.iso developer : Square genre : Role - playing # ... Theme API improvements: Alpha 11 added support for theme-side sorting and filtering, custom settings (\"memory\") and access to the list of all available games.","title":"What changed"},{"location":"user-guide/breaking-changes/#how-to-update","text":"Follow these steps for each of your game directories: Make backups of your collections.txt and metadata.txt files. Update the format: Open your metadata.txt in a text editor and copy its contents. Open the metadata converter page. On the left side, select Pegasus (alpha 10) -- metadata.txt and paste the contents to the text area. On the right side, select Pegasus -- metadata.txt . The results of the conversion will appear shortly. Copy the resulting text back to your metadata.txt file, overwriting everything that was in before it previously. Merge collections.txt and metadata.txt : Open both with a text editor, copy the contents of collections.txt and paste it somewhere into metadata.txt (doesn't matter where, but often it's more readable if it's on the top). You can now delete the collections.txt file. Theme developers: You can find a summary of changes here .","title":"How to update"},{"location":"user-guide/config-dirs/","text":"Configuration directories This page list the directories where Pegasus is allowed to find your configuration files, including themes. All platforms: directory of the program /config directory of the program / INSTALL_DATADIR / (only if defined during a manual build ) Linux: ~/.config/pegasus-frontend/ ( default ) ~/.local/share/pegasus-frontend/ /etc/xdg/pegasus-frontend/ /usr/local/share/pegasus-frontend/ /usr/share/pegasus-frontend/ Windows: C:/Users/[username]/AppData/Local/pegasus-frontend/ ( default ) C:/ProgramData/pegasus-frontend/ macOS: ~/Library/Preferences/pegasus-frontend/ ( default ) ~/Library/Application Support/pegasus-frontend/ /Library/Application Support/pegasus-frontend/ Android: storage /pegasus-frontend , where storage the internal storage, if you have one, otherwise the SD card Portable mode If you launch Pegasus with the --portable command line parameter, it will read/write settings only under directory of the program /config/ .","title":"Config directories"},{"location":"user-guide/config-dirs/#configuration-directories","text":"This page list the directories where Pegasus is allowed to find your configuration files, including themes. All platforms: directory of the program /config directory of the program / INSTALL_DATADIR / (only if defined during a manual build ) Linux: ~/.config/pegasus-frontend/ ( default ) ~/.local/share/pegasus-frontend/ /etc/xdg/pegasus-frontend/ /usr/local/share/pegasus-frontend/ /usr/share/pegasus-frontend/ Windows: C:/Users/[username]/AppData/Local/pegasus-frontend/ ( default ) C:/ProgramData/pegasus-frontend/ macOS: ~/Library/Preferences/pegasus-frontend/ ( default ) ~/Library/Application Support/pegasus-frontend/ /Library/Application Support/pegasus-frontend/ Android: storage /pegasus-frontend , where storage the internal storage, if you have one, otherwise the SD card","title":"Configuration directories"},{"location":"user-guide/config-dirs/#portable-mode","text":"If you launch Pegasus with the --portable command line parameter, it will read/write settings only under directory of the program /config/ .","title":"Portable mode"},{"location":"user-guide/controls/","text":"Default controls Controls can be changed in the Settings menu. The defaults are: Keyboard Gamepad Effect Arrows or navigation / select/ok / cancel/back / game details / filter and search or L1/LB previous collection or R1/RB next collection Page Up L2/LT previous page of games Page Down R2/RT next page of games In addition, if you have a keyboard you may use + [letter] to jump to the first game starting with that letter.","title":"Default controls"},{"location":"user-guide/controls/#default-controls","text":"Controls can be changed in the Settings menu. The defaults are: Keyboard Gamepad Effect Arrows or navigation / select/ok / cancel/back / game details / filter and search or L1/LB previous collection or R1/RB next collection Page Up L2/LT previous page of games Page Down R2/RT next page of games In addition, if you have a keyboard you may use + [letter] to jump to the first game starting with that letter.","title":"Default controls"},{"location":"user-guide/getting-started/","text":"Getting started! Welcome to the documentation of the Pegasus frontend! Here you can find information about how to install and configure Pegasus on your device, and further along, about the various customization possibilities. Let's get started! Installation Pegasus is available for various devices and operating systems. Currently there are official releases for the following platforms: Windows Linux Raspberry Pi Android macOS You can find the latest releases on pegasus-frontend.org , under the Downloads section. On most platforms, Pegasus is just a single file, which you can extract and run anywhere on your system. If there are additional system requirements, they are mentioned on the download page as well. Other platforms Pegasus can also run on platforms not listed above, but may need to be compiled manually from source code. If you wish to do that, the Build documentation can help you along the way. Basic navigation The first time you start Pegasus, you'll be either greeted with a message that says no games have been found, or depending on your system, there might be already games present from other sources (eg. Steam or EmulationStation). In either way, you can reach the main menu by pressing the ESC key, the \"back button\" ( / ) on a gamepad, or by dragging out the menu panel from the right edge of the screen with your mouse or finger. You can navigate in the menu (and in the whole program in general) using the arrow keys, the directional buttons, the left stick or your mouse and finger. You can select item by pressing the Enter key, the \"select button\" ( / ) or simply clicking/pressing on an item. Controls For the full list of the default navigation keys and buttons, visit the Controls page . Configuration On the Settings screen, you can set some general parameters, like the language of the interface or whether you'd like to run in full screen or windowed mode. You can also change the \"theme\", the look and feel of the whole program. Pegasus is a program that can collect your list of games from various sources. You can import your list of games from other, already installed game libraries, like Steam, for which there is built-in support. For others, especially emulators and standalone games, you can use Pegasus' own metadata files, which is documented on this page . The behaviour of the game searching can be configured in the Gaming section: The Set game directories option will open a dialog where you can edit the list of directories Pegasus will search for metadata files (see the documentation linked above). On the Enable/disable data sources panel you can enable or disable importing games from the individual data sources that might be available on your system. Outside the Settings menu, there's also the Controls screen, where you can configure your gamepad's layout, and a Help screen that shows some information about Pegasus, and contains a link to this documentation site. Customization Now that you're done with the basics, you might want to dig deeper into the customization aspect of Pegasus. Here are a few articles you could take a look, if you're interested: Metadata files Asset files Scripting Creating themes Back to the index","title":"Getting started"},{"location":"user-guide/getting-started/#getting-started","text":"Welcome to the documentation of the Pegasus frontend! Here you can find information about how to install and configure Pegasus on your device, and further along, about the various customization possibilities. Let's get started!","title":"Getting started!"},{"location":"user-guide/getting-started/#installation","text":"Pegasus is available for various devices and operating systems. Currently there are official releases for the following platforms: Windows Linux Raspberry Pi Android macOS You can find the latest releases on pegasus-frontend.org , under the Downloads section. On most platforms, Pegasus is just a single file, which you can extract and run anywhere on your system. If there are additional system requirements, they are mentioned on the download page as well. Other platforms Pegasus can also run on platforms not listed above, but may need to be compiled manually from source code. If you wish to do that, the Build documentation can help you along the way.","title":"Installation"},{"location":"user-guide/getting-started/#basic-navigation","text":"The first time you start Pegasus, you'll be either greeted with a message that says no games have been found, or depending on your system, there might be already games present from other sources (eg. Steam or EmulationStation). In either way, you can reach the main menu by pressing the ESC key, the \"back button\" ( / ) on a gamepad, or by dragging out the menu panel from the right edge of the screen with your mouse or finger. You can navigate in the menu (and in the whole program in general) using the arrow keys, the directional buttons, the left stick or your mouse and finger. You can select item by pressing the Enter key, the \"select button\" ( / ) or simply clicking/pressing on an item. Controls For the full list of the default navigation keys and buttons, visit the Controls page .","title":"Basic navigation"},{"location":"user-guide/getting-started/#configuration","text":"On the Settings screen, you can set some general parameters, like the language of the interface or whether you'd like to run in full screen or windowed mode. You can also change the \"theme\", the look and feel of the whole program. Pegasus is a program that can collect your list of games from various sources. You can import your list of games from other, already installed game libraries, like Steam, for which there is built-in support. For others, especially emulators and standalone games, you can use Pegasus' own metadata files, which is documented on this page . The behaviour of the game searching can be configured in the Gaming section: The Set game directories option will open a dialog where you can edit the list of directories Pegasus will search for metadata files (see the documentation linked above). On the Enable/disable data sources panel you can enable or disable importing games from the individual data sources that might be available on your system. Outside the Settings menu, there's also the Controls screen, where you can configure your gamepad's layout, and a Help screen that shows some information about Pegasus, and contains a link to this documentation site.","title":"Configuration"},{"location":"user-guide/getting-started/#customization","text":"Now that you're done with the basics, you might want to dig deeper into the customization aspect of Pegasus. Here are a few articles you could take a look, if you're interested: Metadata files Asset files Scripting Creating themes Back to the index","title":"Customization"},{"location":"user-guide/installing-themes/","text":"Installing themes Themes are stored in the theme directory. The default location of that is: Linux : ~/.config/pegasus-frontend/themes/ Windows : C:/Users/[username]/AppData/Local/pegasus-frontend/themes/ macOS : ~/Library/Preferences/pegasus-frontend/themes/ Android : storage /pegasus-frontend/themes/ all platform : directory of the program /config/themes/ If the directory does not exists, you can create it manually. Then simply extract the theme files to this directory and choose the theme in the Settings menu of Pegasus. Info If you wish to place the themes somewhere else, please see this page for the list of directories Pegagus can access.","title":"Installing themes"},{"location":"user-guide/installing-themes/#installing-themes","text":"Themes are stored in the theme directory. The default location of that is: Linux : ~/.config/pegasus-frontend/themes/ Windows : C:/Users/[username]/AppData/Local/pegasus-frontend/themes/ macOS : ~/Library/Preferences/pegasus-frontend/themes/ Android : storage /pegasus-frontend/themes/ all platform : directory of the program /config/themes/ If the directory does not exists, you can create it manually. Then simply extract the theme files to this directory and choose the theme in the Settings menu of Pegasus. Info If you wish to place the themes somewhere else, please see this page for the list of directories Pegagus can access.","title":"Installing themes"},{"location":"user-guide/meta-assets/","text":"Asset searching This page describes how Pegasus is searching for game assets, such as logo images, backgrounds or video files when you're using metadata files . Such media files can come from these sources: A manually set file for the game A manually set default file for the collections A file with a recognized name under directory /media/ gamename / Third-party sources (eg. EmulationStation, Steam) To download assets for all your games automatically, you might want to use a so-called \"scraper\". See the bottom of this page for more details. Assets in the Metadata file All recognized asset types can be set in the metadata.txt (and metadata.pegasus.txt ) file by adding a assets. assetname : file key-value pair for a game. The list of possible asset names can be found HERE . file is the path to the asset file, which can be either relative (to the metadata file) or an absolute path. Example Let's say we have the following structure: gba/ \u251c\u2500 metadata.pegasus.txt \u251c\u2500 Alien Hominid.gba \u2514\u2500 assets/ \u251c\u2500 covers/ \u2502 \u2514\u2500 Alien_Hominid.jpg \u2514\u2500 logos/ \u2514\u2500 Alien_Hominid_logo.jpg Our metadata.txt file could then look like this: game : Alien Hominid file : Alien Hominid . gba developer : Zoo Digital assets.boxFront : assets / covers / Alien_Hominid . jpg assets.logo : assets / logos / Alien_Hominid_logo . jpg Tip asset is also accepted instead of assets . Use whichever you prefer. Default assets in the Collection file Similarly, you can also set default assets for a collection by adding a assets. assetname : file field. However , note that using these default assets depends on the theme set in Pegasus, as a theme's creator can decide to use a different artwork for such purposes as well. Example Continuing the example above, let's say we have an assets/default_cover.jpg file. In this case the collection could be defined like this: collection : Game Boy Advanced extension : gba description : The Game Boy Advance ( GBA ) is a 32- bit handheld video game console developed, manufactured and marketed by Nintendo as the successor to the Game Boy Color. assets.boxFront : assets / default_cover . jpg Tip Similarly, asset is also accepted instead of assets . The media directory If the game's assets haven't beed defined manually, Pegasus will also look for a matching file under gamedir /media/ gamename / , where gamedir is the directory of the games (ie. where metadata.pegasus.txt is), and gamename is a particular game's filename without extension. Example NES/ \u251c\u2500 metadata.pegasus.txt \u251c\u2500 Contra (U).zip \u2514\u2500 media/ \u2514\u2500 Contra (U)/ \u251c\u2500 boxFront.jpg \u251c\u2500 logo.jpg \u2514\u2500 video.mp4 Recognized files For still images, PNG and JPG files are searched, for videos WEBM, MP4 and AVI, and for audio MP3, OGG and WAV. The recognized filenames are: boxFront box_front boxart2D boxBack box_back boxSpine box_spine boxSide box_side boxFull box_full box cartridge disc cart logo wheel marquee bezel screenmarquee border panel cabinetLeft cabinet_left cabinetRight cabinet_right tile banner steam steamgrid grid poster flyer background music screenshot video Third-party sources Pegasus also tries to use the assets of third-party data sources, if possible. Usually no configuration is necessary, just enable the data source in the Settings menu. Internet access might be required, depending on the source (eg. Steam). How to get assets for my games? For larger game libraries, it might be tiresome to download each and every asset manually. To automatize this process, you can use programs called scraper s. These go through all your games, check multiple online databases for available assets, and may even generate a configuration file for you. Some popular scraper programs are Universal XML Scraper, Steven Selph's Scraper, Skraper.net and Skyscraper. Try giving them a go!","title":"Asset files"},{"location":"user-guide/meta-assets/#asset-searching","text":"This page describes how Pegasus is searching for game assets, such as logo images, backgrounds or video files when you're using metadata files . Such media files can come from these sources: A manually set file for the game A manually set default file for the collections A file with a recognized name under directory /media/ gamename / Third-party sources (eg. EmulationStation, Steam) To download assets for all your games automatically, you might want to use a so-called \"scraper\". See the bottom of this page for more details.","title":"Asset searching"},{"location":"user-guide/meta-assets/#assets-in-the-metadata-file","text":"All recognized asset types can be set in the metadata.txt (and metadata.pegasus.txt ) file by adding a assets. assetname : file key-value pair for a game. The list of possible asset names can be found HERE . file is the path to the asset file, which can be either relative (to the metadata file) or an absolute path.","title":"Assets in the Metadata file"},{"location":"user-guide/meta-assets/#example","text":"Let's say we have the following structure: gba/ \u251c\u2500 metadata.pegasus.txt \u251c\u2500 Alien Hominid.gba \u2514\u2500 assets/ \u251c\u2500 covers/ \u2502 \u2514\u2500 Alien_Hominid.jpg \u2514\u2500 logos/ \u2514\u2500 Alien_Hominid_logo.jpg Our metadata.txt file could then look like this: game : Alien Hominid file : Alien Hominid . gba developer : Zoo Digital assets.boxFront : assets / covers / Alien_Hominid . jpg assets.logo : assets / logos / Alien_Hominid_logo . jpg Tip asset is also accepted instead of assets . Use whichever you prefer.","title":"Example"},{"location":"user-guide/meta-assets/#default-assets-in-the-collection-file","text":"Similarly, you can also set default assets for a collection by adding a assets. assetname : file field. However , note that using these default assets depends on the theme set in Pegasus, as a theme's creator can decide to use a different artwork for such purposes as well.","title":"Default assets in the Collection file"},{"location":"user-guide/meta-assets/#example_1","text":"Continuing the example above, let's say we have an assets/default_cover.jpg file. In this case the collection could be defined like this: collection : Game Boy Advanced extension : gba description : The Game Boy Advance ( GBA ) is a 32- bit handheld video game console developed, manufactured and marketed by Nintendo as the successor to the Game Boy Color. assets.boxFront : assets / default_cover . jpg Tip Similarly, asset is also accepted instead of assets .","title":"Example"},{"location":"user-guide/meta-assets/#the-media-directory","text":"If the game's assets haven't beed defined manually, Pegasus will also look for a matching file under gamedir /media/ gamename / , where gamedir is the directory of the games (ie. where metadata.pegasus.txt is), and gamename is a particular game's filename without extension.","title":"The media directory"},{"location":"user-guide/meta-assets/#example_2","text":"NES/ \u251c\u2500 metadata.pegasus.txt \u251c\u2500 Contra (U).zip \u2514\u2500 media/ \u2514\u2500 Contra (U)/ \u251c\u2500 boxFront.jpg \u251c\u2500 logo.jpg \u2514\u2500 video.mp4 Recognized files For still images, PNG and JPG files are searched, for videos WEBM, MP4 and AVI, and for audio MP3, OGG and WAV. The recognized filenames are: boxFront box_front boxart2D boxBack box_back boxSpine box_spine boxSide box_side boxFull box_full box cartridge disc cart logo wheel marquee bezel screenmarquee border panel cabinetLeft cabinet_left cabinetRight cabinet_right tile banner steam steamgrid grid poster flyer background music screenshot video","title":"Example"},{"location":"user-guide/meta-assets/#third-party-sources","text":"Pegasus also tries to use the assets of third-party data sources, if possible. Usually no configuration is necessary, just enable the data source in the Settings menu. Internet access might be required, depending on the source (eg. Steam).","title":"Third-party sources"},{"location":"user-guide/meta-assets/#how-to-get-assets-for-my-games","text":"For larger game libraries, it might be tiresome to download each and every asset manually. To automatize this process, you can use programs called scraper s. These go through all your games, check multiple online databases for available assets, and may even generate a configuration file for you. Some popular scraper programs are Universal XML Scraper, Steven Selph's Scraper, Skraper.net and Skyscraper. Try giving them a go!","title":"How to get assets for my games?"},{"location":"user-guide/meta-examples/","text":"Real-world examples On this page, some real-world examples have been collected for the various supported platforms. (under construction) Android Let's say I want to play my NES and PSP games on Android. I'd like to use RetroArch with the fceumm core (installed from its menu) for emulating NES, and use the standalone PPSSPP app for PSP. After copying the roms to the SD card, my directory structure looks like this (games are examples) : [SD card] \u2514\u2500 Roms \u251c\u2500 NES \u2502 \u251c\u2500 Contra.zip \u2502 \u2514\u2500 Super Mario.zip \u2514\u2500 PSP \u251c\u2500 Patapon.iso \u2514\u2500 Lumines.cso I've also downloaded assets (like box art and video) for my games using a scraper . To make pegasus automatically find them, I place them in a directory called media for each system: [SD card] \u2514\u2500 Roms \u251c\u2500 NES \u2502 \u251c\u2500 media \u2502 \u2502 \u251c\u2500 Contra \u2502 \u2502 \u2502 \u251c\u2500 boxFront.png \u2502 \u2502 \u2502 \u2514\u2500 video.mp4 \u2502 \u2502 \u2514\u2500 Super Mario \u2502 \u2502 \u251c\u2500 boxFront.png \u2502 \u2502 \u2514\u2500 video.mp4 \u2502 \u251c\u2500 Contra.zip \u2502 \u2514\u2500 Super Mario.zip \u2514\u2500 PSP \u251c\u2500 media \u2502 \u251c\u2500 Patapon \u2502 \u2502 \u2514\u2500 boxFront.png \u2502 \u2514\u2500 Lumines \u2502 \u251c\u2500 boxFront.png \u2502 \u2514\u2500 video.mp4 \u251c\u2500 Patapon.iso \u2514\u2500 Lumines.cso (see the documentation here ) Now I create a metadata file for each system. As mentioned in the Android platform notes , RetroArch happens to need a bunch of parameters, but PPSSPP can just open the file directly. Here are my configs: [SD card]/Roms/NES/metadata.pegasus.txt collection : NES extensions : zip launch : am start --user 0 -n com.retroarch/.browser.retroactivity.RetroActivityFuture -e ROM {file.path} -e LIBRETRO /data/data/com.retroarch/cores/fceumm_libretro_android.so -e CONFIGFILE /storage/emulated/0/Android/data/com.retroarch/files/retroarch.cfg -e IME com.android.inputmethod.latin/.LatinIME -e DATADIR /data/data/com.retroarch -e APK /data/app/com.retroarch-1/base.apk -e SDCARD /storage/emulated/0 -e DOWNLOADS /storage/emulated/0/Download -e SCREENSHOTS /storage/emulated/0/Pictures -e EXTERNAL /storage/emulated/0/Android/data/com.retroarch/files --activity-clear-top [SD card]/Roms/PSP/metadata.pegasus.txt collection : PSP extension : iso , cso launch : am start --user 0 -a android.intent.action.VIEW -d file://{file.path} SD card path In the above configurations I use /storage/emulated/0/ which is the path of the SD card on my device. This might be different for you! You can check the path in most file manager apps, look for something like \"file details\" or similar. While it's optional, I'd also like some descriptions and such for my games, so I add the following as well as well: [SD card]/Roms/NES/metadata.pegasus.txt ... game : Contra file : Contra . zip developer : Konami players : 2 description : In the year 2633 , the evil Red Falcon Organization have set a base on the Galuga archipelago near New Zealand in a plot to conquer the world. Two commandos, Pfc. Bill Rizer and Pfc. Lance Bean of the Contra unit ( an elite group of soldiers specializing in guerrilla warfare ) , are sent to the island to destroy the enemy forces and uncover the true nature of Red Falcon, the alien entity controlling them. game : Super Mario Bros . file : Super Mario . zip developer : Nintendo players : 2 description : In the fantasy setting of the Mushroom Kingdom , a tribe of turtle - like creatures known as the Koopa Troopas invade the kingdom and uses the magic of its king, Bowser, to turn its inhabitants, known as the Mushroom People, into inanimate objects such as bricks, stones and horsehair plants. Bowser and his army also kidnap Princess Toadstool, the princess of the Mushroom Kingdom and the only one with the ability to reverse Bowsers spell. After hearing the news, Mario sets out to save the princess and free the kingdom from Bowser. [SD card]/Roms/PSP/metadata.pegasus.txt ... game : Patapon file : Patapon . iso description : For years the Patapon tribe has lived in the desolate frontier , driven from their home by the evil Zigoton army. Behind the Patapons cute exterior, lies a fierce warrior spirit that can only be commanded by the beat of their God\u2019s war drum. They wait for the day that the Almighty will return , to lead them against their enemies and bring them back to their homeland. Finally, their wait has come to an end as the drums of war are heard once again. game : LUMINES file : Lumines . cso description : LUMINES brings minimalism to the puzzle genre where the fusion of light and sound sets the stage for a two-color falling block experience in HD and 4K. Groove to electronic jams while strategically dropping blocks before the BPM bar sweeps combos clean after each measure. After that, I open Pegasus, go to the Settings menu Set game directories, and add both collection files to the list. At the moment, Pegasus have to be restarted for the changes to take effect, so I quit using the menu. Then starting Pegasus again, the games should appear as expected.","title":"Real world examples"},{"location":"user-guide/meta-examples/#real-world-examples","text":"On this page, some real-world examples have been collected for the various supported platforms. (under construction)","title":"Real-world examples"},{"location":"user-guide/meta-examples/#android","text":"Let's say I want to play my NES and PSP games on Android. I'd like to use RetroArch with the fceumm core (installed from its menu) for emulating NES, and use the standalone PPSSPP app for PSP. After copying the roms to the SD card, my directory structure looks like this (games are examples) : [SD card] \u2514\u2500 Roms \u251c\u2500 NES \u2502 \u251c\u2500 Contra.zip \u2502 \u2514\u2500 Super Mario.zip \u2514\u2500 PSP \u251c\u2500 Patapon.iso \u2514\u2500 Lumines.cso I've also downloaded assets (like box art and video) for my games using a scraper . To make pegasus automatically find them, I place them in a directory called media for each system: [SD card] \u2514\u2500 Roms \u251c\u2500 NES \u2502 \u251c\u2500 media \u2502 \u2502 \u251c\u2500 Contra \u2502 \u2502 \u2502 \u251c\u2500 boxFront.png \u2502 \u2502 \u2502 \u2514\u2500 video.mp4 \u2502 \u2502 \u2514\u2500 Super Mario \u2502 \u2502 \u251c\u2500 boxFront.png \u2502 \u2502 \u2514\u2500 video.mp4 \u2502 \u251c\u2500 Contra.zip \u2502 \u2514\u2500 Super Mario.zip \u2514\u2500 PSP \u251c\u2500 media \u2502 \u251c\u2500 Patapon \u2502 \u2502 \u2514\u2500 boxFront.png \u2502 \u2514\u2500 Lumines \u2502 \u251c\u2500 boxFront.png \u2502 \u2514\u2500 video.mp4 \u251c\u2500 Patapon.iso \u2514\u2500 Lumines.cso (see the documentation here ) Now I create a metadata file for each system. As mentioned in the Android platform notes , RetroArch happens to need a bunch of parameters, but PPSSPP can just open the file directly. Here are my configs: [SD card]/Roms/NES/metadata.pegasus.txt collection : NES extensions : zip launch : am start --user 0 -n com.retroarch/.browser.retroactivity.RetroActivityFuture -e ROM {file.path} -e LIBRETRO /data/data/com.retroarch/cores/fceumm_libretro_android.so -e CONFIGFILE /storage/emulated/0/Android/data/com.retroarch/files/retroarch.cfg -e IME com.android.inputmethod.latin/.LatinIME -e DATADIR /data/data/com.retroarch -e APK /data/app/com.retroarch-1/base.apk -e SDCARD /storage/emulated/0 -e DOWNLOADS /storage/emulated/0/Download -e SCREENSHOTS /storage/emulated/0/Pictures -e EXTERNAL /storage/emulated/0/Android/data/com.retroarch/files --activity-clear-top [SD card]/Roms/PSP/metadata.pegasus.txt collection : PSP extension : iso , cso launch : am start --user 0 -a android.intent.action.VIEW -d file://{file.path} SD card path In the above configurations I use /storage/emulated/0/ which is the path of the SD card on my device. This might be different for you! You can check the path in most file manager apps, look for something like \"file details\" or similar. While it's optional, I'd also like some descriptions and such for my games, so I add the following as well as well: [SD card]/Roms/NES/metadata.pegasus.txt ... game : Contra file : Contra . zip developer : Konami players : 2 description : In the year 2633 , the evil Red Falcon Organization have set a base on the Galuga archipelago near New Zealand in a plot to conquer the world. Two commandos, Pfc. Bill Rizer and Pfc. Lance Bean of the Contra unit ( an elite group of soldiers specializing in guerrilla warfare ) , are sent to the island to destroy the enemy forces and uncover the true nature of Red Falcon, the alien entity controlling them. game : Super Mario Bros . file : Super Mario . zip developer : Nintendo players : 2 description : In the fantasy setting of the Mushroom Kingdom , a tribe of turtle - like creatures known as the Koopa Troopas invade the kingdom and uses the magic of its king, Bowser, to turn its inhabitants, known as the Mushroom People, into inanimate objects such as bricks, stones and horsehair plants. Bowser and his army also kidnap Princess Toadstool, the princess of the Mushroom Kingdom and the only one with the ability to reverse Bowsers spell. After hearing the news, Mario sets out to save the princess and free the kingdom from Bowser. [SD card]/Roms/PSP/metadata.pegasus.txt ... game : Patapon file : Patapon . iso description : For years the Patapon tribe has lived in the desolate frontier , driven from their home by the evil Zigoton army. Behind the Patapons cute exterior, lies a fierce warrior spirit that can only be commanded by the beat of their God\u2019s war drum. They wait for the day that the Almighty will return , to lead them against their enemies and bring them back to their homeland. Finally, their wait has come to an end as the drums of war are heard once again. game : LUMINES file : Lumines . cso description : LUMINES brings minimalism to the puzzle genre where the fusion of light and sound sets the stage for a two-color falling block experience in HD and 4K. Groove to electronic jams while strategically dropping blocks before the BPM bar sweeps combos clean after each measure. After that, I open Pegasus, go to the Settings menu Set game directories, and add both collection files to the list. At the moment, Pegasus have to be restarted for the changes to take effect, so I quit using the menu. Then starting Pegasus again, the games should appear as expected.","title":"Android"},{"location":"user-guide/meta-files/","text":"Metadata files Pegasus supports several gaming platforms out of the box, but other than those, you can also add your own custom games and emulators. These can be described using metadata files . A metadata file is a human-readable text file that stores information about the individual games (title, developers, release date, etc.), and groups the games into categories (eg. \"Playstation games\", \"Mario games\", etc.). Here is an example (with more details below): collection : Game Boy Advanced extension : gba launch : myemulator { file . path } game : Advance Wars file : Advance Wars ( USA ). gba developer : Intelligent Games genre : Strategy players : 4 description : This turn-based strategy game hails back to a classic Japanese strategy game titled Famicom Wars. Advance Wars pits players against very computer AI in a number of battles involving submarines, warships, infantry, tanks, helicopters, and other weapons. rating : 80% These files are named metadata.pegasus.txt , and Pegasus looks for them in the directories you've added under Settings menu Set game directories . Alternative file names If metadata.pegasus.txt doesn't exists, Pegasus will also try to load metadata.txt . Use whichever filename you prefer. Global config files The metadata files are usually kept together with the games. If you prefer to have them separately in one place, that is also possible: Pegasus will also look for them in the config dir /metafiles , if this directory exists. The possible config directories are listed HERE . Third-party data sources Pegasus is compatible with various third-party sources, such as EmulationStation and Steam, and can recognize their games automatically. You can turn on/off support for these sources in the Settings menu. For more details, see the documentation HERE . File format The metadata files are text files that contain property: value entries: collection : PlayStation extension : iso files : specialgame1.bin specialgame2.ext ignore-file : buggygame . iso launch : myemulator { file . path } game : Final Fantasy VII files : ffvii_disc1.iso ffvii_disc2.iso developer : Square genre : Role - playing players : 1 description : Final Fantasy VII is a 1997 role - playing video game developed by Square for the PlayStation console. It is the seventh main installment in the Final Fantasy series. . The game s story follows Cloud Strife, a mercenary who joins an eco-terrorist organization to stop a world-controlling megacorporation from using the planet s life essence as an energy source. rating : 92% x-scrape-source : SomeScraper Entries always start on a new line. Property names are case insensitive, so title , Title and TitLe are the same. Values have two different types: text: simple human-readable text, like titles or descriptions (actually most of the fields belong to this category). Long texts can be broken into multiple lines to improve readability. Empty lines can be represented with a single dot ( . ). item list: one or more items (eg. files), with one item per line. For multiline fields, each line except the very first one (where the property name is) must start with at least one space or tab. Lines starting with # are comments and will be ignored. There are two kinds of elements in a metadata file: Collections and Games. All entries belong to the last defined collection or game entry in metadata files. Collections Collections define which files in the directory (and its subdirectories) should be treated as games, and thus appear in Pegasus. It also stores information about how to launch them (eg. open in emulator X, or run with parameter Y). All games are grouped into collections, but one game can belong to as many collections as you wish. Basics The following fields define some basic properties : Key Description collection Creates a new collection with the value as name (if it was not created yet). The properties after this line will modify this collection. This is a required field. launch A common launch command for the games in this collection. If a game has its own custom launch command, that will override this field. There are some placeholder variables you can use here, see below for more details. command An alternate name for launch . Use whichever you prefer. workdir The default working directory used when launching a game. Defaults to the directory of the launched program. cwd An alternate name for workdir . Use whichever you prefer. Multiple directories Collections can span over multiple metadata files if they have the same name . This means you can create categories such as \"Platformer games\" in multiple locations, and the games will still belong to the same collection. Include The following fields control which files of the directory should be included in the collection: Key Description extension , extensions A comma-separated list of file extensions (without the . dot). All files with these extensions (including those in subdirectories) will be included. This field can appear multiple times. file , files A single file or a list of files to add to the collection. This field can appear multiple times. regex A Perl-compatible regular expression string, without leading or trailing slashes. Relative file paths matching the regex will be included. Unicode is supported. directory , directories A single directory or a list of directories to search for matching games (see below). This field can appear multiple times. Foreign directories By default, a metadata file is expected to be next to the games, and files are searched in the directory of the this file. If you also want to search for matching files in other directories (eg. you prefer to keep the metadata separately), you can list them under directories (similarly to the files, one directory per line). Exclude The file-related fields above with the ignore- prefix control which files should be excluded : Key Description ignore-extension , ignore-extensions Similarly to extension above. ignore-file , ignore-files Similarly to file above. ignore-regex Similarly to regex above. Exclusion is stronger than inclusion If both the normal and the ignore- fields match for a file, it will be excluded. Plural forms Sometimes writing the plural forms of the fields feels more natural, so directories , files , ignore-extensions , etc. are also supported without any difference to their regular forms. Metadata The following fields can tell some additional information : Key Description shortname An optional short name for the collection, often an abbreviation (like MAME, NES, etc.). Should be lowercase. summary A short description of the collection in one paragraph. description A possibly longer description of the collection. Keys starting with x- can be used to extend the format with additional data. This could be used, for example, by other softwares (eg. scrapers) to store some program-specific data. Launch command parameters The following variables will be replaced in the launch command value: Variable Description Example {file.path} Absolute path to the file. /home/joe/games/mygame.bin {file.name} The file name part of the path mygame.bin {file.basename} The file name without extension (ie. until but not including the last dot) mygame {file.dir} The directory where the file is located. /home/joe/games {env.MYVAR} The value of the environment variable MYVAR , if defined. launch: x11app --tty={env.TTY} Note that the variables will be replaced as-is, without additional formatting. You might need to wrap them in quotes if necessary. Example Let's say you have Super Nintendo games under C:/games/snes . Then you'd create C:/games/snes/metadata.pegasus.txt with the following contents: # Selects all files with the provided extension, except two games collection : Super Nintendo Entertainment System shortname : snes extensions : 7 z , bin , smc , sfc , fig , swc , mgd , zip , bin ignore-file : buggygame . bin ignore-file : duplicategame . bin launch : snes 9 x { file . path } # A collection of 3 games. They re also part of My Games . collection : Platformer games files : mario 1. bin files : mario 2. bin files : mario 3. bin # A regex example; includes games with [number]-in-1 in their name. collection : Multi - game carts regex : \\ d +. in .1 Then add C:/games/snes to the searched game directories in the Settings menu. The games and categories will appear the next time you start Pegasus. Games Game entries store additional information about the individual games, such as title, developer(s) or release date. If a game need a special way to get launched, it can also be set here. The following properties can be used in game entries: Key Description game Creates a new game with the value as title. The properties after this line will modify this game. This is a required field. file , files The file or list of files (eg. disks) that belong to this game. If there are multiple files, you'll be able to select which one to launch when you start the game. developer , developers The developer or list of developers. This field can appear multiple times. publisher , publishers The publisher or list of publishers. This field can appear multiple times. genre , genres The genre or list of genres. This field can appear multiple times. summary A short description of the game in one paragraph. description A possibly longer description of the game. players The number of players who can play the game. Either a single number (eg. 2 ) or a number range (eg. 1-4 ). release The date when the game was released, in YYYY-MM-DD format (eg. 1985-05-22 ). Month and day can be omitted if unknown (eg. 1985-05 or 1985 alone is also accepted). rating The rating of the game, in percentages. Either an integer percentage in the 0-100% range (eg. 70% ), or a fractional value between 0 and 1 (eg. 0.7 ). launch If this game must be launched differently than the others in the same collection, a custom launch command can be defined for it. command An alternate name for launch . Use whichever you prefer. workdir The working directory in which the game is launched. Defaults to the directory of the launched program. cwd An alternate name for workdir . Use whichever you prefer. Like with the collections, keys starting with x- can be used to extend the format with additional data. This could be used, for example, by other softwares (eg. scrapers) to store some program-specific data. Game requirements Only games that belong to at least one collection and have at least one existing file will appear in Pegasus. Example Continuing with the collection example, the C:/games/snes/metadata.pegasus.txt file could be extended with game data like this: game : Alien Hominid file : Alien Hominid ( Europe ) ( En , Fr , De , Es , It ). gba developer : Zoo Digital genre : Shooter players : 1 summary : You re a little yellow alien . The FBI has shot down your ship while flying over planet Earth. And it, quite literally, lands right on their doorstep. After a series of FBI Agents swipe your ship, what option do you have other than to blow up everything in your path to get it back? description : Alien Hominid is a 2D side-scrolling shooter with heavy references to the Metal Slug series of games - from the hand-drawn graphics, huge explosions, right down to the ability to eviscerate FBI Agents when you get up close to them. The graphics are by featured artist Dan Paladin. Your goal, is quite simply, to get to the end of the stage, and die as little as possible. Which is made difficult due to the fact that any bullet is an instant kill. . To help you out, you can grab a range of power-ups, such as lasers, spread shots, shotguns and more, as well as hijacking vehicles and using them for protection. Grenades can be lobbed, and you can jump on enemy shoulders and choose to bite their heads off if you like, or pick them up and throw them at other enemies. You can also dive underground for a short period of time to avoid enemies - while underground, you can drag agents into the ground to kill them. rating : 50% x-id : 4149 x-source : ScreenScraper Asset files You can add various assets (eg. cover art) for your games. This is documented HERE . Real-world examples Here are some real examples collected on this page for the various platforms.","title":"Metadata files"},{"location":"user-guide/meta-files/#metadata-files","text":"Pegasus supports several gaming platforms out of the box, but other than those, you can also add your own custom games and emulators. These can be described using metadata files . A metadata file is a human-readable text file that stores information about the individual games (title, developers, release date, etc.), and groups the games into categories (eg. \"Playstation games\", \"Mario games\", etc.). Here is an example (with more details below): collection : Game Boy Advanced extension : gba launch : myemulator { file . path } game : Advance Wars file : Advance Wars ( USA ). gba developer : Intelligent Games genre : Strategy players : 4 description : This turn-based strategy game hails back to a classic Japanese strategy game titled Famicom Wars. Advance Wars pits players against very computer AI in a number of battles involving submarines, warships, infantry, tanks, helicopters, and other weapons. rating : 80% These files are named metadata.pegasus.txt , and Pegasus looks for them in the directories you've added under Settings menu Set game directories . Alternative file names If metadata.pegasus.txt doesn't exists, Pegasus will also try to load metadata.txt . Use whichever filename you prefer. Global config files The metadata files are usually kept together with the games. If you prefer to have them separately in one place, that is also possible: Pegasus will also look for them in the config dir /metafiles , if this directory exists. The possible config directories are listed HERE . Third-party data sources Pegasus is compatible with various third-party sources, such as EmulationStation and Steam, and can recognize their games automatically. You can turn on/off support for these sources in the Settings menu. For more details, see the documentation HERE .","title":"Metadata files"},{"location":"user-guide/meta-files/#file-format","text":"The metadata files are text files that contain property: value entries: collection : PlayStation extension : iso files : specialgame1.bin specialgame2.ext ignore-file : buggygame . iso launch : myemulator { file . path } game : Final Fantasy VII files : ffvii_disc1.iso ffvii_disc2.iso developer : Square genre : Role - playing players : 1 description : Final Fantasy VII is a 1997 role - playing video game developed by Square for the PlayStation console. It is the seventh main installment in the Final Fantasy series. . The game s story follows Cloud Strife, a mercenary who joins an eco-terrorist organization to stop a world-controlling megacorporation from using the planet s life essence as an energy source. rating : 92% x-scrape-source : SomeScraper Entries always start on a new line. Property names are case insensitive, so title , Title and TitLe are the same. Values have two different types: text: simple human-readable text, like titles or descriptions (actually most of the fields belong to this category). Long texts can be broken into multiple lines to improve readability. Empty lines can be represented with a single dot ( . ). item list: one or more items (eg. files), with one item per line. For multiline fields, each line except the very first one (where the property name is) must start with at least one space or tab. Lines starting with # are comments and will be ignored. There are two kinds of elements in a metadata file: Collections and Games. All entries belong to the last defined collection or game entry in metadata files.","title":"File format"},{"location":"user-guide/meta-files/#collections","text":"Collections define which files in the directory (and its subdirectories) should be treated as games, and thus appear in Pegasus. It also stores information about how to launch them (eg. open in emulator X, or run with parameter Y). All games are grouped into collections, but one game can belong to as many collections as you wish.","title":"Collections"},{"location":"user-guide/meta-files/#basics","text":"The following fields define some basic properties : Key Description collection Creates a new collection with the value as name (if it was not created yet). The properties after this line will modify this collection. This is a required field. launch A common launch command for the games in this collection. If a game has its own custom launch command, that will override this field. There are some placeholder variables you can use here, see below for more details. command An alternate name for launch . Use whichever you prefer. workdir The default working directory used when launching a game. Defaults to the directory of the launched program. cwd An alternate name for workdir . Use whichever you prefer. Multiple directories Collections can span over multiple metadata files if they have the same name . This means you can create categories such as \"Platformer games\" in multiple locations, and the games will still belong to the same collection.","title":"Basics"},{"location":"user-guide/meta-files/#include","text":"The following fields control which files of the directory should be included in the collection: Key Description extension , extensions A comma-separated list of file extensions (without the . dot). All files with these extensions (including those in subdirectories) will be included. This field can appear multiple times. file , files A single file or a list of files to add to the collection. This field can appear multiple times. regex A Perl-compatible regular expression string, without leading or trailing slashes. Relative file paths matching the regex will be included. Unicode is supported. directory , directories A single directory or a list of directories to search for matching games (see below). This field can appear multiple times. Foreign directories By default, a metadata file is expected to be next to the games, and files are searched in the directory of the this file. If you also want to search for matching files in other directories (eg. you prefer to keep the metadata separately), you can list them under directories (similarly to the files, one directory per line).","title":"Include"},{"location":"user-guide/meta-files/#exclude","text":"The file-related fields above with the ignore- prefix control which files should be excluded : Key Description ignore-extension , ignore-extensions Similarly to extension above. ignore-file , ignore-files Similarly to file above. ignore-regex Similarly to regex above. Exclusion is stronger than inclusion If both the normal and the ignore- fields match for a file, it will be excluded. Plural forms Sometimes writing the plural forms of the fields feels more natural, so directories , files , ignore-extensions , etc. are also supported without any difference to their regular forms.","title":"Exclude"},{"location":"user-guide/meta-files/#metadata","text":"The following fields can tell some additional information : Key Description shortname An optional short name for the collection, often an abbreviation (like MAME, NES, etc.). Should be lowercase. summary A short description of the collection in one paragraph. description A possibly longer description of the collection. Keys starting with x- can be used to extend the format with additional data. This could be used, for example, by other softwares (eg. scrapers) to store some program-specific data.","title":"Metadata"},{"location":"user-guide/meta-files/#launch-command-parameters","text":"The following variables will be replaced in the launch command value: Variable Description Example {file.path} Absolute path to the file. /home/joe/games/mygame.bin {file.name} The file name part of the path mygame.bin {file.basename} The file name without extension (ie. until but not including the last dot) mygame {file.dir} The directory where the file is located. /home/joe/games {env.MYVAR} The value of the environment variable MYVAR , if defined. launch: x11app --tty={env.TTY} Note that the variables will be replaced as-is, without additional formatting. You might need to wrap them in quotes if necessary.","title":"Launch command parameters"},{"location":"user-guide/meta-files/#example","text":"Let's say you have Super Nintendo games under C:/games/snes . Then you'd create C:/games/snes/metadata.pegasus.txt with the following contents: # Selects all files with the provided extension, except two games collection : Super Nintendo Entertainment System shortname : snes extensions : 7 z , bin , smc , sfc , fig , swc , mgd , zip , bin ignore-file : buggygame . bin ignore-file : duplicategame . bin launch : snes 9 x { file . path } # A collection of 3 games. They re also part of My Games . collection : Platformer games files : mario 1. bin files : mario 2. bin files : mario 3. bin # A regex example; includes games with [number]-in-1 in their name. collection : Multi - game carts regex : \\ d +. in .1 Then add C:/games/snes to the searched game directories in the Settings menu. The games and categories will appear the next time you start Pegasus.","title":"Example"},{"location":"user-guide/meta-files/#games","text":"Game entries store additional information about the individual games, such as title, developer(s) or release date. If a game need a special way to get launched, it can also be set here. The following properties can be used in game entries: Key Description game Creates a new game with the value as title. The properties after this line will modify this game. This is a required field. file , files The file or list of files (eg. disks) that belong to this game. If there are multiple files, you'll be able to select which one to launch when you start the game. developer , developers The developer or list of developers. This field can appear multiple times. publisher , publishers The publisher or list of publishers. This field can appear multiple times. genre , genres The genre or list of genres. This field can appear multiple times. summary A short description of the game in one paragraph. description A possibly longer description of the game. players The number of players who can play the game. Either a single number (eg. 2 ) or a number range (eg. 1-4 ). release The date when the game was released, in YYYY-MM-DD format (eg. 1985-05-22 ). Month and day can be omitted if unknown (eg. 1985-05 or 1985 alone is also accepted). rating The rating of the game, in percentages. Either an integer percentage in the 0-100% range (eg. 70% ), or a fractional value between 0 and 1 (eg. 0.7 ). launch If this game must be launched differently than the others in the same collection, a custom launch command can be defined for it. command An alternate name for launch . Use whichever you prefer. workdir The working directory in which the game is launched. Defaults to the directory of the launched program. cwd An alternate name for workdir . Use whichever you prefer. Like with the collections, keys starting with x- can be used to extend the format with additional data. This could be used, for example, by other softwares (eg. scrapers) to store some program-specific data. Game requirements Only games that belong to at least one collection and have at least one existing file will appear in Pegasus.","title":"Games"},{"location":"user-guide/meta-files/#example_1","text":"Continuing with the collection example, the C:/games/snes/metadata.pegasus.txt file could be extended with game data like this: game : Alien Hominid file : Alien Hominid ( Europe ) ( En , Fr , De , Es , It ). gba developer : Zoo Digital genre : Shooter players : 1 summary : You re a little yellow alien . The FBI has shot down your ship while flying over planet Earth. And it, quite literally, lands right on their doorstep. After a series of FBI Agents swipe your ship, what option do you have other than to blow up everything in your path to get it back? description : Alien Hominid is a 2D side-scrolling shooter with heavy references to the Metal Slug series of games - from the hand-drawn graphics, huge explosions, right down to the ability to eviscerate FBI Agents when you get up close to them. The graphics are by featured artist Dan Paladin. Your goal, is quite simply, to get to the end of the stage, and die as little as possible. Which is made difficult due to the fact that any bullet is an instant kill. . To help you out, you can grab a range of power-ups, such as lasers, spread shots, shotguns and more, as well as hijacking vehicles and using them for protection. Grenades can be lobbed, and you can jump on enemy shoulders and choose to bite their heads off if you like, or pick them up and throw them at other enemies. You can also dive underground for a short period of time to avoid enemies - while underground, you can drag agents into the ground to kill them. rating : 50% x-id : 4149 x-source : ScreenScraper","title":"Example"},{"location":"user-guide/meta-files/#asset-files","text":"You can add various assets (eg. cover art) for your games. This is documented HERE .","title":"Asset files"},{"location":"user-guide/meta-files/#real-world-examples","text":"Here are some real examples collected on this page for the various platforms.","title":"Real-world examples"},{"location":"user-guide/meta-sources/","text":"Other data sources Pegasus is compatible with various third-party sources, such as EmulationStation and Steam, and can recognize their games automatically, often with all the available assets as well. You can turn on/off support for these sources in the Settings menu, under Enable/disable data sources . Other than Pegasus' own configuration files , there is also support for the applications below. EmulationStation Available on: desktop Linux, embedded Linux, Windows, macOS If you have EmulationStation installed and set up, Pegasus will also check the directories set in es_systems.cfg , read the gamelist.xml files in them and use the metadata and assets defined there, and also check for assets in config dir /downloaded_images (where config dir is eg. ~/.emulationstation ). A tool for converting between ES and Pegasus files can be found HERE . Compared to ES files, the collection file is like es_systems.cfg , except it's local to the directory it's placed in, while the metadata file is mostly equal to gamelist.xml . Steam Available on: desktop Linux, Windows, macOS It just works, no additional configuration is necessary. Installed Steam games should automatically appear in Pegasus with metadata and multimedia assets. On Windows you might need to install DirectShow codecs for video playback. You can download them HERE , look for opencodecs_ version .exe . GOG Available on: desktop Linux, Windows On Windows, this works out of the box, like Steam. Similarly to GOG Galaxy, games installed older than a few years ago might not be detected, due to a change in GOG's installers. In this case, try downloading the game again from GOG.com and reinstall it. On Linux, there's way less information available offline, so support is a bit hit and miss. Games installed in the default location ( home /GOG Games ) can be detected, but assets might me missing (for the games installed somewhere else, you can always just create symlinks). If you have games that refuse to show up, feel free to report it as an issue. Android Apps Available on: Android It just works. Installed and launchable apps will appear in Pegasus just like with any other Android launcher. Note that no metadata and assets are available at the time of writing; this will be improved in the future. Skraper Assets Available on: all platforms Pegasus can recognize the assets (\"media\" directory) layout created by Skraper. Pegasus will look for assets in [game directory]/skraper and [game directory]/media , for the game directories set in the Settings menu.","title":"Other data sources"},{"location":"user-guide/meta-sources/#other-data-sources","text":"Pegasus is compatible with various third-party sources, such as EmulationStation and Steam, and can recognize their games automatically, often with all the available assets as well. You can turn on/off support for these sources in the Settings menu, under Enable/disable data sources . Other than Pegasus' own configuration files , there is also support for the applications below.","title":"Other data sources"},{"location":"user-guide/meta-sources/#emulationstation","text":"Available on: desktop Linux, embedded Linux, Windows, macOS If you have EmulationStation installed and set up, Pegasus will also check the directories set in es_systems.cfg , read the gamelist.xml files in them and use the metadata and assets defined there, and also check for assets in config dir /downloaded_images (where config dir is eg. ~/.emulationstation ). A tool for converting between ES and Pegasus files can be found HERE . Compared to ES files, the collection file is like es_systems.cfg , except it's local to the directory it's placed in, while the metadata file is mostly equal to gamelist.xml .","title":"EmulationStation"},{"location":"user-guide/meta-sources/#steam","text":"Available on: desktop Linux, Windows, macOS It just works, no additional configuration is necessary. Installed Steam games should automatically appear in Pegasus with metadata and multimedia assets. On Windows you might need to install DirectShow codecs for video playback. You can download them HERE , look for opencodecs_ version .exe .","title":"Steam"},{"location":"user-guide/meta-sources/#gog","text":"Available on: desktop Linux, Windows On Windows, this works out of the box, like Steam. Similarly to GOG Galaxy, games installed older than a few years ago might not be detected, due to a change in GOG's installers. In this case, try downloading the game again from GOG.com and reinstall it. On Linux, there's way less information available offline, so support is a bit hit and miss. Games installed in the default location ( home /GOG Games ) can be detected, but assets might me missing (for the games installed somewhere else, you can always just create symlinks). If you have games that refuse to show up, feel free to report it as an issue.","title":"GOG"},{"location":"user-guide/meta-sources/#android-apps","text":"Available on: Android It just works. Installed and launchable apps will appear in Pegasus just like with any other Android launcher. Note that no metadata and assets are available at the time of writing; this will be improved in the future.","title":"Android Apps"},{"location":"user-guide/meta-sources/#skraper-assets","text":"Available on: all platforms Pegasus can recognize the assets (\"media\" directory) layout created by Skraper. Pegasus will look for assets in [game directory]/skraper and [game directory]/media , for the game directories set in the Settings menu.","title":"Skraper Assets"},{"location":"user-guide/platform-android/","text":"Platform Notes: Android Pegasus is available for Android devices running at least Android 4.1 (Jelly Bean). For proper multimedia support, Android 4.4 (KitKat) or newer is recommended. Installation Pegasus is released as an APK package. To install it, you'll need to enable such files, which can be done under Settings Security Unknown Sources , turned on. Then open the APK file with any file manager app. If you have an active full screen app (eg. screen shade), Android might not allow you to press on the install button due to security reasons. In this case, just disable that app for the time of the installation. Config directory Config files are stored under storage /pegasus-frontend , where storage the internal storage, if you have one, otherwise the SD card. The directory will be created automatically when you first launch Pegasus (or you can create it yourself). Loading games Compared to desktop systems, launching other applications is slightly different on Android. Instead of directly calling a program, you'll need to ask the Activity Manager ( am ) to open a file or start an app, optionally with additional parameters. Here's how it looks in practice: Open a file with the default app The best case is when you have a file format associated with an app already. To open a file with its default app, invoke the Activity Manager like this: am start --user 0 -a android.intent.action.VIEW -d file:// path-to-file Here is an example metadata.txt that will open ISO files with the default app: collection : PSP extension : iso launch : am start -- user 0 -a android.intent.action.VIEW -d file://{file.path} Help am is the Activity Manager program the start command sends an app launching request (\"intent\") to the Activity Manager --user 0 selects the user (by ID) that sends this request. Without this parameter I've got permission denied errors on my devices. -a stands for \"action\"; if an app supports opening files ( android.intent.action.VIEW ie. \"open with\"), it will react to this action. There are other possible actions, like \"take a photo\" or \"call a taxi\", but we probably won't need them for our use. -d is the parameter (data) of the action, and must be in such URI format ( file://... ) The full documentation of am can be found here and here . If you're not familiar with Pegasus' config files, you can find their documentation here . Note that not every app supports opening arbitrary files, or opening files at all (for example, RetroArch). In addition, there seems to be a glich on some systems where a file may get opened with something else when there are multiple apps that can handle the file type. Which leads to... Open a file with a specific app Unfortunately opening a file with anything else than the default is a bit painful. To open the file, you have to know the exact name of the app component (\"activity\") that handles file opening requests. For example, for the Android version of the PPSSPP emulator, this is org.ppsspp.ppsspp/.PpssppActivity . I haven't found a good app yet that could tell this about the installed apps, so I guess the best bet for now is either asking the developers for a particular app or looking into its source code (tip: it's always in AndroidManifest.xml ). I've also made a small collection which you can find at the bottom of this page . Anyway, once you know the Activity you want to call, the command is am start --user 0 -a android.intent.action.VIEW -n activity-name -d file:// path-to-file Help -n stands for \"name\" Here is an example metadata.txt that will open ISO files with PPSSPP: collection : PSP extension : iso launch : am start -- user 0 -a android.intent.action.VIEW -n org.ppsspp.ppsspp/.PpssppActivity -d file://{file.path} Run a custom command Some apps simply don't support opening files, for example because they rely on a built-in file browser or some other reasons. The way to call these apps may differ from what's described above, or they might need additional parameters. You'll have to ask the developers or look around the source code in this case. See below for some examples. App-specific notes RetroArch RetroArch happens to use a large number of custom parameters. It can be launched like this: collection : NES extensions : zip launch : am start -- user 0 -n com.retroarch/.browser.retroactivity.RetroActivityFuture -e ROM {file.path} -e LIBRETRO /data/data/com.retroarch/cores/fceumm_libretro_android.so -e CONFIGFILE /storage/emulated/0/Android/data/com.retroarch/files/retroarch.cfg -e IME com.android.inputmethod.latin/.LatinIME -e DATADIR /data/data/com.retroarch -e APK /data/app/com.retroarch-1/base.apk -e SDCARD /storage/emulated/0 -e DOWNLOADS /storage/emulated/0/Download -e SCREENSHOTS /storage/emulated/0/Pictures -e EXTERNAL /storage/emulated/0/Android/data/com.retroarch/files --activity-clear-top (based on the source code of their Android port at the time of writing). The important parts here are the core and the storage paths. Make sure you correct the paths of the above example to match your system and collection: /storage/emulated/0 is the absolute path to the internal storage on my phone. This can be completely different on other devices (eg. /storage/sdcard ). Most file browser apps can tell you the correct path, then you can replace all occurences above. /data/data/com.retroarch/cores/fceumm_libretro_android.so is the libretro core I've installed using the RetroArch menu. You'll only need to change the fceumm_libretro_android.so part. You can find the available cores here . Help -e KEY VALUE defines an extra parameter, specific to the app. Unlike the file opening before, RetroArch does not need file:// for the ROM path. Known emulators Here's an incomplete list of emulators that can open external files using android.intent.action.VIEW . If you think some some of the entries are incorrect, or you'd like to extend this list, feel free to open an Issue here . App name Activity 2600.emu com.explusalpha.A2600Emu/com.imagine.BaseActivity C54.emu com.explusalpha.C64Emu/com.imagine.BaseActivity ClassicBoy com.portableandroid.classicboyLite/com.portableandroid.classicboy.EntryActivity DraStic com.dsemu.drastic/.DraSticActivity Emulator for NES/SNES - Arcade Classic Games no support ePSXe com.epsxe.ePSXe/com.dropbox.client2.android.AuthActivity GBA.emu com.explusalpha.GbaEmu/com.imagine.BaseActivity GBC.emu com.explusalpha.GbcEmu/com.imagine.BaseActivity John emulators no support MD.emu com.explusalpha.MdEmu/com.imagine.BaseActivity MegaN64 no support MSX.emu com.explusalpha.MsxEmu/com.imagine.BaseActivity Mupen64 Plus AE paulscode.android.mupen64plusae/.MainActivity Neo.emu com.explusalpha.NeoEmu/com.imagine.BaseActivity NES.emu com.explusalpha.NesEmu/com.imagine.BaseActivity NGP.emu com.explusalpha.NgpEmu/com.imagine.BaseActivity Nostalgia.NES no support PPSSPP org.ppsspp.ppsspp/.PpssppActivity Reicast com.reicast.emulator/.MainActivity Snes9xPlus com.explusalpha.Snes9xPlus/com.imagine.BaseActivity SuperRetro16 com.bubblezapgames.supergnes/.IntentFilterActivity SuperRetro16 Lite com.bubblezapgames.supergnes_lite/com.bubblezapgames.supergnes.IntentFilterActivity Additional notes Video playback has a high battery drain Unmounting the SD card while Pegasus is running may force close it If you're launching a memory-intensive application, the Android OS may decide to close Pegasus Shutdown and reboot are not avaliable due to Android restrictions","title":"Android"},{"location":"user-guide/platform-android/#platform-notes-android","text":"Pegasus is available for Android devices running at least Android 4.1 (Jelly Bean). For proper multimedia support, Android 4.4 (KitKat) or newer is recommended.","title":"Platform Notes: Android"},{"location":"user-guide/platform-android/#installation","text":"Pegasus is released as an APK package. To install it, you'll need to enable such files, which can be done under Settings Security Unknown Sources , turned on. Then open the APK file with any file manager app. If you have an active full screen app (eg. screen shade), Android might not allow you to press on the install button due to security reasons. In this case, just disable that app for the time of the installation.","title":"Installation"},{"location":"user-guide/platform-android/#config-directory","text":"Config files are stored under storage /pegasus-frontend , where storage the internal storage, if you have one, otherwise the SD card. The directory will be created automatically when you first launch Pegasus (or you can create it yourself).","title":"Config directory"},{"location":"user-guide/platform-android/#loading-games","text":"Compared to desktop systems, launching other applications is slightly different on Android. Instead of directly calling a program, you'll need to ask the Activity Manager ( am ) to open a file or start an app, optionally with additional parameters. Here's how it looks in practice:","title":"Loading games"},{"location":"user-guide/platform-android/#open-a-file-with-the-default-app","text":"The best case is when you have a file format associated with an app already. To open a file with its default app, invoke the Activity Manager like this: am start --user 0 -a android.intent.action.VIEW -d file:// path-to-file Here is an example metadata.txt that will open ISO files with the default app: collection : PSP extension : iso launch : am start -- user 0 -a android.intent.action.VIEW -d file://{file.path} Help am is the Activity Manager program the start command sends an app launching request (\"intent\") to the Activity Manager --user 0 selects the user (by ID) that sends this request. Without this parameter I've got permission denied errors on my devices. -a stands for \"action\"; if an app supports opening files ( android.intent.action.VIEW ie. \"open with\"), it will react to this action. There are other possible actions, like \"take a photo\" or \"call a taxi\", but we probably won't need them for our use. -d is the parameter (data) of the action, and must be in such URI format ( file://... ) The full documentation of am can be found here and here . If you're not familiar with Pegasus' config files, you can find their documentation here . Note that not every app supports opening arbitrary files, or opening files at all (for example, RetroArch). In addition, there seems to be a glich on some systems where a file may get opened with something else when there are multiple apps that can handle the file type. Which leads to...","title":"Open a file with the default app"},{"location":"user-guide/platform-android/#open-a-file-with-a-specific-app","text":"Unfortunately opening a file with anything else than the default is a bit painful. To open the file, you have to know the exact name of the app component (\"activity\") that handles file opening requests. For example, for the Android version of the PPSSPP emulator, this is org.ppsspp.ppsspp/.PpssppActivity . I haven't found a good app yet that could tell this about the installed apps, so I guess the best bet for now is either asking the developers for a particular app or looking into its source code (tip: it's always in AndroidManifest.xml ). I've also made a small collection which you can find at the bottom of this page . Anyway, once you know the Activity you want to call, the command is am start --user 0 -a android.intent.action.VIEW -n activity-name -d file:// path-to-file Help -n stands for \"name\" Here is an example metadata.txt that will open ISO files with PPSSPP: collection : PSP extension : iso launch : am start -- user 0 -a android.intent.action.VIEW -n org.ppsspp.ppsspp/.PpssppActivity -d file://{file.path}","title":"Open a file with a specific app"},{"location":"user-guide/platform-android/#run-a-custom-command","text":"Some apps simply don't support opening files, for example because they rely on a built-in file browser or some other reasons. The way to call these apps may differ from what's described above, or they might need additional parameters. You'll have to ask the developers or look around the source code in this case. See below for some examples.","title":"Run a custom command"},{"location":"user-guide/platform-android/#app-specific-notes","text":"","title":"App-specific notes"},{"location":"user-guide/platform-android/#retroarch","text":"RetroArch happens to use a large number of custom parameters. It can be launched like this: collection : NES extensions : zip launch : am start -- user 0 -n com.retroarch/.browser.retroactivity.RetroActivityFuture -e ROM {file.path} -e LIBRETRO /data/data/com.retroarch/cores/fceumm_libretro_android.so -e CONFIGFILE /storage/emulated/0/Android/data/com.retroarch/files/retroarch.cfg -e IME com.android.inputmethod.latin/.LatinIME -e DATADIR /data/data/com.retroarch -e APK /data/app/com.retroarch-1/base.apk -e SDCARD /storage/emulated/0 -e DOWNLOADS /storage/emulated/0/Download -e SCREENSHOTS /storage/emulated/0/Pictures -e EXTERNAL /storage/emulated/0/Android/data/com.retroarch/files --activity-clear-top (based on the source code of their Android port at the time of writing). The important parts here are the core and the storage paths. Make sure you correct the paths of the above example to match your system and collection: /storage/emulated/0 is the absolute path to the internal storage on my phone. This can be completely different on other devices (eg. /storage/sdcard ). Most file browser apps can tell you the correct path, then you can replace all occurences above. /data/data/com.retroarch/cores/fceumm_libretro_android.so is the libretro core I've installed using the RetroArch menu. You'll only need to change the fceumm_libretro_android.so part. You can find the available cores here . Help -e KEY VALUE defines an extra parameter, specific to the app. Unlike the file opening before, RetroArch does not need file:// for the ROM path.","title":"RetroArch"},{"location":"user-guide/platform-android/#known-emulators","text":"Here's an incomplete list of emulators that can open external files using android.intent.action.VIEW . If you think some some of the entries are incorrect, or you'd like to extend this list, feel free to open an Issue here . App name Activity 2600.emu com.explusalpha.A2600Emu/com.imagine.BaseActivity C54.emu com.explusalpha.C64Emu/com.imagine.BaseActivity ClassicBoy com.portableandroid.classicboyLite/com.portableandroid.classicboy.EntryActivity DraStic com.dsemu.drastic/.DraSticActivity Emulator for NES/SNES - Arcade Classic Games no support ePSXe com.epsxe.ePSXe/com.dropbox.client2.android.AuthActivity GBA.emu com.explusalpha.GbaEmu/com.imagine.BaseActivity GBC.emu com.explusalpha.GbcEmu/com.imagine.BaseActivity John emulators no support MD.emu com.explusalpha.MdEmu/com.imagine.BaseActivity MegaN64 no support MSX.emu com.explusalpha.MsxEmu/com.imagine.BaseActivity Mupen64 Plus AE paulscode.android.mupen64plusae/.MainActivity Neo.emu com.explusalpha.NeoEmu/com.imagine.BaseActivity NES.emu com.explusalpha.NesEmu/com.imagine.BaseActivity NGP.emu com.explusalpha.NgpEmu/com.imagine.BaseActivity Nostalgia.NES no support PPSSPP org.ppsspp.ppsspp/.PpssppActivity Reicast com.reicast.emulator/.MainActivity Snes9xPlus com.explusalpha.Snes9xPlus/com.imagine.BaseActivity SuperRetro16 com.bubblezapgames.supergnes/.IntentFilterActivity SuperRetro16 Lite com.bubblezapgames.supergnes_lite/com.bubblezapgames.supergnes.IntentFilterActivity","title":"Known emulators"},{"location":"user-guide/platform-android/#additional-notes","text":"Video playback has a high battery drain Unmounting the SD card while Pegasus is running may force close it If you're launching a memory-intensive application, the Android OS may decide to close Pegasus Shutdown and reboot are not avaliable due to Android restrictions","title":"Additional notes"},{"location":"user-guide/platform-linux/","text":"Platform notes: Linux Pegasus runs on both desktop and embedded Linux devices, but due to the number of different distributions and conventions it's not possible to support all configurations. On desktop, the official builds always support the last two stable releases of Ubuntu, while on the Raspberry Pi, the last two stable releases of Raspbian. However other than a few required system libraries, Pegasus is mostly self-contained, so as long as you have a fairly up-to-date system, you may be able to run the official builds without problem. In general, the dependencies on Linux are: GStreamer 1.x (for video playback) Fontconfig (for typography) OpenSSL 1.0.x (for networking) PolicyKit (optional, for shutting down/restarting the device without admin rights) Another important thing to note is that depending on your settings, the system may not allow running programs from USB drives or Windows file systems . This is not a bug, but something you might want to be aware of. Ubuntu At the time of writing, the official builds require Ubuntu 16.04 or later . All dependencies come preinstalled, so you can just extract and use the official builds as they are. If, for some reason the dependencies are missing, you can install them like this: sudo apt-get install \\ gstreamer1.0-alsa \\ gstreamer1.0-libav \\ gstreamer1.0-plugins-good \\ fontconfig \\ libssl1.0.0 \\ policykit-1 Raspbian On the Raspberry Pi, the official builds require Raspbian Jessie or later . All Raspberry boards are supported, however the releases are generally not interchangeable: trying to launch an executable made for a different device will result in Illegal instruction errors. There are various ways to set up Raspbian, so to make sure you have all the dependencies ready, install them the same way as mentioned in the Ubuntu section above. A desktop installation (X11) is not required, so you can also use the \"Lite\" versions of Raspbian on your boards. In addition, Pegasus requires at least 64 MB of video RAM. You can change the memory split of the Raspberry Pi using raspi-config . Arch A community maintained package is available from AUR. You can install it using your favorite AUR helper: yay -S pegasus-fe-git # or trizen -S pegasus-fe-git # or yaourt -S pegasus-fe-git # etc. or get it manually: git clone https://aur.archlinux.org/pegasus-fe-git.git cd pegasus-fe-git makepkg -si Custom builds As always, you can build Pegasus from source for your platform. You can find the instructions for that HERE .","title":"Linux"},{"location":"user-guide/platform-linux/#platform-notes-linux","text":"Pegasus runs on both desktop and embedded Linux devices, but due to the number of different distributions and conventions it's not possible to support all configurations. On desktop, the official builds always support the last two stable releases of Ubuntu, while on the Raspberry Pi, the last two stable releases of Raspbian. However other than a few required system libraries, Pegasus is mostly self-contained, so as long as you have a fairly up-to-date system, you may be able to run the official builds without problem. In general, the dependencies on Linux are: GStreamer 1.x (for video playback) Fontconfig (for typography) OpenSSL 1.0.x (for networking) PolicyKit (optional, for shutting down/restarting the device without admin rights) Another important thing to note is that depending on your settings, the system may not allow running programs from USB drives or Windows file systems . This is not a bug, but something you might want to be aware of.","title":"Platform notes: Linux"},{"location":"user-guide/platform-linux/#ubuntu","text":"At the time of writing, the official builds require Ubuntu 16.04 or later . All dependencies come preinstalled, so you can just extract and use the official builds as they are. If, for some reason the dependencies are missing, you can install them like this: sudo apt-get install \\ gstreamer1.0-alsa \\ gstreamer1.0-libav \\ gstreamer1.0-plugins-good \\ fontconfig \\ libssl1.0.0 \\ policykit-1","title":"Ubuntu"},{"location":"user-guide/platform-linux/#raspbian","text":"On the Raspberry Pi, the official builds require Raspbian Jessie or later . All Raspberry boards are supported, however the releases are generally not interchangeable: trying to launch an executable made for a different device will result in Illegal instruction errors. There are various ways to set up Raspbian, so to make sure you have all the dependencies ready, install them the same way as mentioned in the Ubuntu section above. A desktop installation (X11) is not required, so you can also use the \"Lite\" versions of Raspbian on your boards. In addition, Pegasus requires at least 64 MB of video RAM. You can change the memory split of the Raspberry Pi using raspi-config .","title":"Raspbian"},{"location":"user-guide/platform-linux/#arch","text":"A community maintained package is available from AUR. You can install it using your favorite AUR helper: yay -S pegasus-fe-git # or trizen -S pegasus-fe-git # or yaourt -S pegasus-fe-git # etc. or get it manually: git clone https://aur.archlinux.org/pegasus-fe-git.git cd pegasus-fe-git makepkg -si","title":"Arch"},{"location":"user-guide/platform-linux/#custom-builds","text":"As always, you can build Pegasus from source for your platform. You can find the instructions for that HERE .","title":"Custom builds"},{"location":"user-guide/platform-retropie/","text":"Platform notes: RetroPie Other than the official Raspberry Pi releases you can found on the download page , Pegasus is also from the RetroPie repositories. You can install it by two ways: a) From the RetroPie setup menu b) Using the Frontend Chooser tool Note: you will need RetroPie version 4.3 (released on September 21, 2017) or later to install Pegasus through RetroPie. From the setup menu You can start the RetroPie setup script from the terminal ( sudo ~/RetroPie-Setup/retropie_setup.sh ) or from another already installed frontend. You will be greeted with a text-based interface. To install Pegasus, select Manage Packages Manage experimental packages pegasus-fe Install from binary . The latest release will then be downloaded. You can also update your existing installation here. After the installation, you can either call /opt/retropie/supplementary/pegasus-fe/pegasus-fe manually, or edit /opt/retropie/configs/all/autostart.sh to launch Pegasus on boot (instead of eg. ES2). Using the Frontend Chooser There's also a graphical tool for installing various frontend and setting them up to boot automatically. It is available from HERE .","title":"RetroPie"},{"location":"user-guide/platform-retropie/#platform-notes-retropie","text":"Other than the official Raspberry Pi releases you can found on the download page , Pegasus is also from the RetroPie repositories. You can install it by two ways: a) From the RetroPie setup menu b) Using the Frontend Chooser tool Note: you will need RetroPie version 4.3 (released on September 21, 2017) or later to install Pegasus through RetroPie.","title":"Platform notes: RetroPie"},{"location":"user-guide/platform-retropie/#from-the-setup-menu","text":"You can start the RetroPie setup script from the terminal ( sudo ~/RetroPie-Setup/retropie_setup.sh ) or from another already installed frontend. You will be greeted with a text-based interface. To install Pegasus, select Manage Packages Manage experimental packages pegasus-fe Install from binary . The latest release will then be downloaded. You can also update your existing installation here. After the installation, you can either call /opt/retropie/supplementary/pegasus-fe/pegasus-fe manually, or edit /opt/retropie/configs/all/autostart.sh to launch Pegasus on boot (instead of eg. ES2).","title":"From the setup menu"},{"location":"user-guide/platform-retropie/#using-the-frontend-chooser","text":"There's also a graphical tool for installing various frontend and setting them up to boot automatically. It is available from HERE .","title":"Using the Frontend Chooser"},{"location":"user-guide/scripting/","text":"Scripting Pegasus supports calling external scripts and executables on certain program events. 1. The scripts directory First, find your config directory and create a new directory there called scripts (eg. ~/.config/pegasus-frontend/scripts/ ). 2. Event directories Inside the scripts folder, create a new directory for the kind of events for which you want to react: Name When quit on program quit reboot on system reboot (also calls quit first) shutdown on system shutdown (also calls quit first) config-changed on the change of any configuration option controls-changed on change of the control settings (also calls config first) settings-changed on change of the regular (non-control) settings (also calls config first) game-start before starting a game game-end after finishing a game 3. Script calling Put your executable scripts or binaries into these new directories. They will be called in alphabetic order when the event happens.","title":"Scripting"},{"location":"user-guide/scripting/#scripting","text":"Pegasus supports calling external scripts and executables on certain program events.","title":"Scripting"},{"location":"user-guide/scripting/#1-the-scripts-directory","text":"First, find your config directory and create a new directory there called scripts (eg. ~/.config/pegasus-frontend/scripts/ ).","title":"1. The scripts directory"},{"location":"user-guide/scripting/#2-event-directories","text":"Inside the scripts folder, create a new directory for the kind of events for which you want to react: Name When quit on program quit reboot on system reboot (also calls quit first) shutdown on system shutdown (also calls quit first) config-changed on the change of any configuration option controls-changed on change of the control settings (also calls config first) settings-changed on change of the regular (non-control) settings (also calls config first) game-start before starting a game game-end after finishing a game","title":"2. Event directories"},{"location":"user-guide/scripting/#3-script-calling","text":"Put your executable scripts or binaries into these new directories. They will be called in alphabetic order when the event happens.","title":"3. Script calling"}]}